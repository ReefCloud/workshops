[
  {
    "objectID": "01_introduction_to_r.html",
    "href": "01_introduction_to_r.html",
    "title": "Introduction to R",
    "section": "",
    "text": "The latest version of an R installation binary (or source code) can be downloaded from one of the Comprehensive R Archive Network (or CRAN) mirrors. Having selected one of the (Australian) mirrors, follow one of the sets of instructions below (depending on your operating system).\n\nWindowsMacOSxLinux\n\n\n\nDownload R:\n\nGo to the CRAN R-project website https://cran.r-project.org/ and click on “Download R for Windows”.\nSelect the “base” subdirectory\nSelect the “Download R-X.X.X for Windows” option (where X.X.X are a series of version and release numbers) to download.\n\nRun the installer: Double-click the downloaded .exe file and follow the installation wizard. Accept the default settings unless you have specific needs.\nOptional: Set R as the default: Check the checkbox to set R as the default for R scripts during installation. This allows you to run R scripts by double-clicking them.\nVerify installation:\n\nOpen a new command prompt (Start &gt; Run &gt; cmd) and type R. If the R console opens, the installation was successful.\nAlternatively, search for R in the Start menu\n\n\n\n\n\nDownload R:\n\nGo to the CRAN R-project website (https://cran.r-project.org/) and click on “Download R for macOS”.\nChoose the latest stable version that is appropriate for your architecture.\n\nOpen the disk image: Double-click the downloaded .pkg file and drag the R application icon to your Applications folder.\nVerify installation:\n\nOpen Terminal: Go to Applications &gt; Utilities and open Terminal.\nType R in the Terminal window. If the R console opens, the installation was successful.\n\n\n\n\n\nOpen Terminal: You can access Terminal through your application launcher or search bar.\nInstall R: The commands vary slightly depending on your Linux distribution. Here are common examples:\n\nDebian/Ubuntu: sudo apt install r-base\nFedora/CentOS: sudo yum install R\nArch Linux: sudo pacman -S R\n\n**Verify installation:* Type R in the Terminal window. If the R console opens, the installation was successful."
  },
  {
    "objectID": "01_introduction_to_r.html#the-r-environment-and-command-line",
    "href": "01_introduction_to_r.html#the-r-environment-and-command-line",
    "title": "Introduction to R",
    "section": "2.1 The R environment and command line",
    "text": "2.1 The R environment and command line\nUpon opening R, you are presented with the R Console along with the command prompt (&gt;). R is a command driven application (as opposed to a ‘point-and-click’ application) and despite the steep learning curve, there are many very good reasons for this.\nCommands that you type are evaluated once the Enter key has been pressed\nEnter the following command (5+1) at the command prompt (&gt;);\n\n5+1\n\n[1] 6\n\n\n\n\n\n\n\n\nNote\n\n\n\nI have suppressed the command prompt (&lt;) from almost all code blocks throughout these workshop and tutorial series to make it easier for you to cut and paste code into your own scripts or directly into R.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn this tutorial series, the R code to be entered appears to the right hand side of the vertical bar. The number of the left side of the bar is a line number. For single line code snippets, such as the example above, line numbers are not necessary. However, for multi-line code snippets, line numbers help for identifying and describing different parts of the code.\n\n\nThe above R code evaluates the command five plus one and returns the result (six).. The [1] before the 6 indicates that the object immediately to its right is the first element in the returned object. In this case there is only one object returned. However, when a large set of objects (e.g. numbers) are returned, each row will start with an index number thereby making it easier to count through the elements.\n\n\n\n\n\n\nImportant definitions\n\n\n\n\n\n\nObject\n\nAs an object oriented language, everything in R is an object. Data, functions even output are objects.\n\nVector\n\nA collection of one or more objects of the same type (e.g. all numbers or all characters).\n\nFunction\n\nA set of instructions carried out on one or more objects. Functions are typically wrappers for a sequence of instructions that perform specific and common tasks.\n\nParameter\n\nThe kind of information passed to a function.\n\nArgument\n\nThe specific information passed to a function.\n\nOperator\n\nA symbol that has a pre-defined meaning. Familiar operators include + - * and /.\n\nAssignment operators\n\n&lt;- Assigning a name to an object (left to right)\n\n\n-&gt; Assigning a name to an object (right to left)\n\n\n= Used when defining and specifying function arguments\n\nLogical operators (return TRUE or FALSE)\n\n&lt; Less than\n\n\n&gt; Greater than\n\n\n&lt;= Less than or equal\n\n\n&gt;= Greater than or equal\n\n\n== Is the left hand side equal to the right hand side (a query)\n\n\n!= Is the left hand side NOT equal to the right hand side (a query)\n\n\n&& Are BOTH left hand and right hand conditions TRUE\n\n\n|| Are EITHER the left hand OR right hand conditions TRUE\n\nPipe operator\n\n|&gt; piping the output of one operation to the input of the next\n\n\n\n\n\n\n2.1.1 Expressions, Assignment and Arithmetic\nInstead of evaluating a statement and printing the result directly to the console, the results of evaluations can be stored in an object via a process called ‘Assignment’. Assignment assigns a name to an object and stores the result of an evaluation in that object. The contents of an object can be viewed (printed) by typing the name of the object at the command prompt and hitting Enter.\n\nvar1 &lt;- 2 + 3\nvar1\n\n[1] 5\n\n\nOn line 1 above, the name var1 was assigned to the result of the sum of 2 and 3. On line 2, the contents of this object are printed to the screen.\nA single command (statement) can spread over multiple lines. If the Enter key is pressed before R considers the statement complete, the next line in the console will begin with the prompt + indicating that the statement is not complete. For this example, I will include the command prompt in order to demonstrate the above point.\n\n&gt; var2 &lt;-\n+   2 + 3\n&gt; var2\n\n[1] 5\n\n\nWhen the contents of an object are numbers, standard arithmetic applies;\n\nvar2 - 1\n\n[1] 4\n\nans1 &lt;- var1 * var2\nans1\n\n[1] 25\n\n\n\n\n\n\n\n\nTip\n\n\n\nGenerally, spaces are ignored in R. Hence, the above and the following are both equally valid.\n\nans1&lt;-var1*var2\nans1\n\n[1] 25\n\n\nNevertheless, the former version (with spaces) is much more readable.\n\n\nCompatible objects can be concatenated (joined together) to create objects with multiple entries. Object concatenation can be performed using the c() function.\n\nc(1, 2, 6)\n\n[1] 1 2 6\n\nc(var1, var2)\n\n[1] 5 5\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn both examples above, objects were not assigned names. As a result, the expressions were evaluated and directly printed to the consol without being stored in any way. Doing so is useful for experimenting, however as the results are not stored, they cannot be used in subsequent actions.\n\n\nIn addition to the typical addition, subtraction, multiplication and division operators, there are a number of special operators, the simplest of which are the quotient or integer divide operator (%/%) and the remainder or modulus operator (%%).\n\n7 / 3\n\n[1] 2.333333\n\n7 %/% 3\n\n[1] 2\n\n7 %% 3\n\n[1] 1\n\n\n\n\n2.1.2 Operator precedence\nThe rules of operator precedence are listed (highest to lowest) in the following table. Additionally, expressions within parentheses ‘()’ always have highest precedence.\n\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n[ [[\nindexing\n\n\n::\nnamespace\n\n\n$\ncomponent\n\n\n^\nexponentiation (evaluated right to left)\n\n\n-\n+ sign (unary)\n\n\n:\nsequence\n\n\n%special%\nspecial operators (e.g. %/%, %%, %*%, %in%)\n\n\n* /\nmultiplication and division\n\n\n+\n- addition and subtraction\n\n\n&gt; &lt; &gt;= &lt;= == !=\nordering and comparison\n\n\n!\nlogical negation (not)\n\n\n& &&\nlogical AND\n\n\n| ||\nlogical OR\n\n\n~\nformula\n\n\n-&gt; -&gt;&gt;\nassignment (left to right)\n\n\n=\nargument assignment (right to left)\n\n\n&lt;- &lt;&lt;-\nassignment (right to left)\n\n\n?\nhelp\n\n\n\n\n\n2.1.3 Command history\nEach time a command is entered at the R command prompt, the command is also added to a list known as the command history. The up and down arrow keys scroll backward and forward respectively through the session’s command history list and place the top most command at the current R command prompt. Scrolling through the command history enables previous commands to be rapidly re-executed, reviewed or modified and executed.\n\n\n2.1.4 Object names\nEverything created within R are objects. Objects are programming constructs that not only store values (the visible part of an object), they also define other properties of the object (such as the type of information contained in the object) and sometimes they also define certain routines that can be used to store, retrieve and manipulate data within the object.\nImportantly, all objects within R must have unique names to which they can be referred. Names given to any object in R can comprise virtually any sequence of letters and numbers providing that the following rules are adhered to:\n\nNames must begin with a letter (names beginning with numbers or operators are not permitted)\nNames cannot contain the following characters; space , - + * / # % & [ ] { } ( ) ~\n\nWhilst the above rules are necessary, the following naming conventions are also recommended:\n\nonly use lowercase letters and numbers\nuse underscores (_) to separate words (e.g. snake case)\ntry to use names that are both concise and meaningful.\n\nnames should reflect the content of the object. One of the powerful features of R is that there is virtually no limit to the number of objects (variables, datasets, results, models, etc) that can be in use at a time. However, without careful name management, objects can rapidly become misplaced or ambiguous. Therefore, the name of an object should reflect what it is, and what has happened to it. For example, the name log_fish_wts might be given to an object that contains log transformed fish weights. Moreover, many prefer to prefix the object name with a lowercase letter that denotes the type of data containing in the object. For example, d_mean_head_length might indicate that the object contains the mean head lengths stored as a double floating point (real numbers).\nalthough there are no restrictions on the length of names, shorter names are quicker to type and provide less scope for typographical errors and are therefore recommended (of course within the restrictions of the point above).\n\nwhere possible, avoid using names of common predefined functions and variables as this can provide a source of confusion for both you and R. For example, to represent the mean of a head length variable, use something like mean_head_length rather than mean (which is the name of a predefined function within R that calculates the mean of a set of numbers)."
  },
  {
    "objectID": "01_introduction_to_r.html#r-sessions-and-workspaces",
    "href": "01_introduction_to_r.html#r-sessions-and-workspaces",
    "title": "Introduction to R",
    "section": "2.2 R Sessions and Workspaces",
    "text": "2.2 R Sessions and Workspaces\nA number of objects have been created in the current session (a session encapsulates all the activity since the current instance of the R application was started). To review the names of all of the objects in the users current workspace (storage of user created objects);\n\nls()\n\n[1] \"ans1\"            \"has_annotations\" \"var1\"            \"var2\"           \n\n\nYou can also refine the scope of the ls() function to search for object names that match a pattern:\n\nls(pat = \"var\")\n\n[1] \"var1\" \"var2\"\n\nls(pat = \"a*1\")\n\n[1] \"ans1\" \"var1\"\n\n\nThe longer the session is running, the more objects will be created resulting in a very cluttered workspace. Unneeded objects can be removed using the rm() function. The rm() function only performs a side effect (deletes objects), if the function succeeds, it does not return any output. If it does return anything, it will be a warning or error.\n\nrm(var1, var2)   #remove the VAR1 and VAR2 objects\nrm(list = ls())  #remove all user defined objects\n\n\n\n\n\n\n\nNote\n\n\n\nIn the above examples, comments were appended to each line of code. Comments begin with a hash (#) character. Anything that follows a hash character will be ignored (until the end of the line).\nComments provide a convenient way to annotate your code so as to provide more explanation and clarity as to the intention and purpose of the associated code.\n\n\n\n2.2.1 Current working directory\nThe R working directory (location from which files/data are read and written) is by default, either the location of the R executable (or execution path in Linux) or the users home directory. The current working directory can be reviewed and changed (for the session) using the getwd() function and setwd() functions respectively. Note that R uses the Unix/Linux style directory subdivision markers. That is, R uses the forward slash / in path names rather than the regular \\ of Windows.\nWhen using setwd(), you can provide either an absolute path (the full path) or a relative path (relative to the current location). Obviously, you will get a different result to me when you issue the following:\n\ngetwd()                    #review the current working directory\n\n[1] \"/home/runner/work/workshops/workshops/tut\"\n\nsetwd(\"../\")               #change to the parent directory of the current working directory\nlist.files(path = getwd()) #list all files (and directories) in the current working directory\n\n[1] \"docs\"     \"Makefile\" \"tut\"     \n\n\n\n\n2.2.2 Workspaces\nThroughout an R session, all objects (including loaded packages, see ?@sec-packages) that have been added are stored within the R global environment, called the workspace. Occasionally, it is desirable to save the workspace and thus all those objects (vectors, functions, etc) that were in use during a session so that they are available during subsequent sessions. This can be done using the save.image() function. Note, this will save the workspace to a file called .RData in the current working directory (usually the R startup directory), unless a file (filename and path) is supplied as an argument to the save.image() function. A previously saved workspace can be loaded by providing a full path and filename as an argument to the load() function.\nWhilst saving a workspace image can sometimes be convenient, it can also contribute greatly to organisational problems associated with large numbers of obsolete or undocumented objects. Instead, it is usually better to specifically store each of the objects you know you are going to want to have access to across sessions separately.\n\n\n2.2.3 Quitting elegantly\nTo quit R, issue the following command; Note in Windows and MacOSX, the application can also be terminated using the standard Exiting protocols.\n\nq()\n\nYou will then be asked whether or not you wish to save the current workspace. If you do, enter ‘Y’ otherwise enter ‘N’. Unless you have a very good reason to save the workspace, I would suggest that you do not. A workspace generated in a typical session will have numerous poorly named objects (objects created to temporarily store information whilst testing). Next time R starts, it could (likely will) restore this workspace thereby starting with a cluttered workspace, and becoming a potential source of confusion if you inadvertently refer to an object stored during a previous session. Moreover, if the workspace includes additional extension packages, these packages may also be loaded which will prevent them from being updated (often necessary when installing additional packages that depend on other packages)."
  },
  {
    "objectID": "01_introduction_to_r.html#functions",
    "href": "01_introduction_to_r.html#functions",
    "title": "Introduction to R",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nAs wrappers for collections of commands used together to perform a task, functions provide a convenient way of interacting with all of these commands in sequence. Most functions require one or more inputs (parameters), and while a particular function can have multiple parameters, not all are necessarily required (some could have default values). Parameters are parsed to a function as arguments comprising the name of the parameter, an equals operator and the value of the parameter. Hence, arguments are specified as name/value pairs.\nConsider the seq() function, which generates a sequence of values (a vector) according to the values of the arguments. We can see that the default version of this function has the following definition:\n\nstr(seq.default)\n\nfunction (from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, \n    along.with = NULL, ...)  \n\n\n\nif the seq() function is called without any arguments (e.g. seq()), it will return a single number 1. Using the default arguments for the function, it returns a vector starting at 1 (from   = 1), going up to 1 (to = 1) and thus having a length of 1.\nwe can alter this behavior by specifically providing values for the named arguments. The following generates a sequence of numbers from 2 to 10 incrementing by 1 (default):\n\nseq(from = 2, to = 10)\n\n[1]  2  3  4  5  6  7  8  9 10\n\n\nthe following generates a sequence of numbers from 2 to 10 incrementing by 2:\n\nseq(from = 2, to = 10, by = 2)\n\n[1]  2  4  6  8 10\n\n\nalternatively, instead of manipulating the increment space of the sequence, we could specify the desired length of the sequence:\n\nseq(from = 2, to = 10, length.out = 3)\n\n[1]  2  6 10\n\n\nnamed arguments need not include the full name of the parameter, so long as it is unambiguous which parameter is being referred to. For example, length.out could be shortened to just l since there are no other parameters of this function that start with ‘l’:\n\nseq(from = 2, to = 10, l = 4)\n\n[1]  2.000000  4.666667  7.333333 10.000000\n\n\nparameters can also be specified as unnamed arguments provided they are in the order specified in the function definition. For example to generate a sequence of numbers from 2 to 10 incrementing by 2:\n\nseq(2, 10, 2)\n\n[1]  2  4  6  8 10\n\n\nNote, although permittable, it is more difficult to unambiguously read/interpret the code and could easily be a source of bugs.\nnamed and unnamed arguments can be mixed, just remember the above rules about parameter order and unambiguous names:\n\nseq(2, 10, l = 4)\n\n[1]  2.000000  4.666667  7.333333 10.000000"
  },
  {
    "objectID": "01_introduction_to_r.html#function-overloading-polymorphism",
    "href": "01_introduction_to_r.html#function-overloading-polymorphism",
    "title": "Introduction to R",
    "section": "2.4 Function overloading (polymorphism)",
    "text": "2.4 Function overloading (polymorphism)\nMany routines can be applied to different sorts of data. That is, they are somewhat generic. For example, we could calculate the mean (arithmetic center) of a set of numbers or we could calculate the mean of a set of dates or times. Whilst the calculations in both cases are analogous to one another, they nevertheless differ sufficiently so as to warrant separate functions.\nWe could name the functions that calculate the mean of a set of numbers and the mean of a set of dates as mean_numbers and mean_dates respectively. Unfortunately, as this is a relatively common situation, the number of functions to learn rapidly expands. And from the perspective of writing a function that itself contains such a generic function, we would have to write multiple instances of the function in order to handle all the types of data we might want to accommodate.\nTo simplify the process of applying these generic functions, R provides yet another layer that is responsible for determining which of a series of overloaded functions is likely to be applicable according to the nature of the parameters and data parsed as arguments to the function. To see this in action, type mean followed by hitting the TAB key. The TAB key is used for auto-completion and therefore this procedure lists all the objects that begin with the letters ‘mean’.\n\nmean           mean.Date      mean.default   mean.difftime  mean.POSIXct   mean.POSIXlt\n\nIn addition to an object called mean, there are additional objects that are suffixed as a ‘.’ followed by a data type. In this case, the objects mean.default, mean.Date, mean.POSIXct, mean.POSIXlt and mean.difftime are functions that respectively calculate the mean of a set of numbers, dates, times, times, time and differences. The mean function determines which of the other functions is appropriate for the data parsed and then redirects to that appropriate function. Typically, this means that it is only necessary to remember the one generic function (in this case, mean()) as the specific functions are abstracted away.\n\n# mean of a series of numbers\nmean(c(1, 2, 3, 4))\n\n[1] 2.5\n\n# create a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nsample_dates &lt;- seq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\")\n# print (view) these dates\nsample_dates\n\n[1] \"2000-02-29\" \"2000-03-07\" \"2000-03-14\" \"2000-03-21\" \"2000-03-28\"\n[6] \"2000-04-04\" \"2000-04-11\" \"2000-04-18\" \"2000-04-25\"\n\n# calculate the mean of these dates\nmean(sample_dates)\n\n[1] \"2000-03-28\"\n\n## Packages {#sec-packages}\n\nIn the above examples, we called the same function (mean) on both occasions. In the first instance, it was equivalent to calling the mean.default() function and in the second instance the mean.Date() function. Note that the seq() function is similarly overloaded.\nThe above example also illustrates another important behaviour of function arguments. Function calls can be nested within the arguments of other functions and function arguments are evaluated before the function runs. In this way, multiple steps to be truncated together (although for the sake of the codes’ readability and debugging, it is often better to break a problem up into smaller steps).\nIf a function argument itself contains a function (as was the case above with the from = and to = arguments, both of which called the as.Date() function which converts a character string into a date object), the value of the evaluated argument is parsed to the outside function. That is, evaluations are made from the inside to out. The above example, could have been further truncated to;\n\n# calculate the mean of a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nmean(seq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\"))\n\n[1] \"2000-03-28\"\n\n\n\n2.4.1 The pipe character\nAs we can see from the example above, nested functions can be pretty awkward to read. As of version 4.1, R has had a pipe operator. The concept of piping dates back to the early UNIX days when separate programs were chained (‘piped’) together such that the output of one program became the input of the next and so on. This enabled each program to remain relatively simple, yet by piping sequences of programs together, rather complex results could be achieved.\nSimilarly the R pipe operator (|&gt;) enables nested functions to alternatively be expressed as a chain of functions:\n\n# calculate the mean of a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nseq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\") |&gt; mean()\n\n[1] \"2000-03-28\"\n\n\nTo maximise code readability, it is good form to keep lines of code short (less than 80 characters). One way to do this is to place a line break after pipe characters. Moreover, a line break after each function argument allows us to have more topical and granular comments.\n\nseq(                              #take sequence of dates\n  from = as.Date(\"2000-02-29\"),   #from the 29th Feb 2000\n  to = as.Date(\"2000-04-30\"),     #to the 30th April 2000\n  by = \"7 days\") |&gt;               #incrementing by 7 days\n  mean()                          #and calculate the mean\n\n[1] \"2000-03-28\""
  },
  {
    "objectID": "01_introduction_to_r.html#external-functions",
    "href": "01_introduction_to_r.html#external-functions",
    "title": "Introduction to R",
    "section": "2.5 External functions",
    "text": "2.5 External functions\nAs R is a scripting language (rather than a compiled language), it has the potential to be very slow (since syntax checking, machine instruction interpretation, etc must all take place at runtime rather than at compile time). Consequently, many of the functions are actually containers (wrappers) for external code (link libraries) precompiled in either C or Fortran. In this way, the environment can benefit from the flexibility of a scripting language whilst still maintaining most of the speed of a compiled language. Tutorial ? will introduce how to install and load external libraries."
  },
  {
    "objectID": "01_introduction_to_r.html#getting-help",
    "href": "01_introduction_to_r.html#getting-help",
    "title": "Introduction to R",
    "section": "2.6 Getting help",
    "text": "2.6 Getting help\nThere are numerous ways of seeking help on R syntax and functions (the following all ways of finding information about a function that calculates the mean of a vector).\n\nproviding the name of the function as an argument to the help() function\n\nhelp(mean)\n\ntyping the name of the function preceded by a '?'\n\n?mean\n\nto run the examples within the standard help files, use the example() function\n\nexample(mean)\n\nsome packages include demonstrations that showcase their features and use cases. The demo() function provides a user-friendly way to access these demonstrations. For example, to respectively get an overview of the basic graphical procedures in R and get a list of available demonstrations:\n\ndemo(graphics)  #run the graphics demo\ndemo()          #list all demos available on your system\n\nif you don’t know the exact name of the function, the apropos() function is useful as it returns the name of all objects from the current search list that match a specific pattern:\n\napropos('mea')\n\n [1] \".colMeans\"          \".rowMeans\"          \"colMeans\"          \n [4] \"influence.measures\" \"kmeans\"             \"mean\"              \n [7] \"mean.Date\"          \"mean.default\"       \"mean.difftime\"     \n[10] \"mean.POSIXct\"       \"mean.POSIXlt\"       \"rowMeans\"          \n[13] \"weighted.mean\"     \n\n\nif you have no idea what the function is called, the help.search() and help.start() functions search through the regular manuals and the local HTML manuals (via a web browser) respectively for specific terms:\n\nhelp.search('mean')   #search the local R manuals\nhelp.start()          #search the local HTML R manuals\n\nto get a snapshot of the order and default values of a functions’ arguments, use the args() function:\n\nargs(mean)         #the arguments that apply to the mean function \n\nfunction (x, ...) \nNULL\n\nargs(list.files)   #the arguments that apply to the list.files function\n\nfunction (path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, \n    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, \n    no.. = FALSE) \nNULL\n\n\n\nThe ... argument indicates that other arguments can also be provided that are then parsed onto other functions that may be called within the main function."
  },
  {
    "objectID": "01_introduction_to_r.html#vectors",
    "href": "01_introduction_to_r.html#vectors",
    "title": "Introduction to R",
    "section": "3.1 Vectors",
    "text": "3.1 Vectors\nVectors are a collection of one or more entries (values) of the same type (class) and are the basic storage unit in R. Vectors are one-dimensional arrays (have a single dimension - length) and can be thought of as a single column of data. Each entry in a vector has a unique index (like a row number) to enable reference to particular entries in the vector.\n\n3.1.1 Consecutive integers\nTo get a vector of consecutive integers, we can specify an expression of the form &lt;first integer&gt;:&lt;second integer&gt; where &lt;first integer&gt; and &lt;second integer&gt; represent the start and end of the sequence of integers respectively:\n\n5:10\n\n[1]  5  6  7  8  9 10\n\n5:-5\n\n [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\n\n\n\n3.1.2 The c() function\nThe c() function concatenates values together into a vector. To create a vector with the numbers 1, 4, 7, 21:\n\nc(1, 4, 7, 21)\n\n[1]  1  4  7 21\n\n\nAs an example, we could store the temperature recorded at 10 sites:\n\ntemperature &lt;- c(36.1, 30.6, 31, 36.3, 39.9, 6.5, 11.2, 12.8, 9.7, 15.9)\ntemperature\n\n [1] 36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9\n\n\nTo create a vector with the words ‘Fish’, ‘Rock’, ‘Tree’, ‘Git’:\n\nc('Fish', 'Rock', 'Tree', \"Git\")\n\n[1] \"Fish\" \"Rock\" \"Tree\" \"Git\" \n\n\n\n\n3.1.3 Regular or patterned sequences (rep())\nWe have already seen the use of the seq() function to create sequences of entries.\nSequences of repeated entries are supported with the rep() function:\n\nrep(4,5)\n\n[1] 4 4 4 4 4\n\nrep('Fish',5)\n\n[1] \"Fish\" \"Fish\" \"Fish\" \"Fish\" \"Fish\"\n\n\n\n\n3.1.4 The paste() function\nTo create a sequence of quadrat labels we could use the c() function as illustrated above, e.g.\n\nquadrats &lt;- c(\"Q1\",\"Q2\",\"Q3\",\"Q4\",\"Q5\",\"Q6\",\"Q7\",\"Q8\",\"Q9\",\"Q10\")\nquadrats\n\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n\nA more elegant way of doing this is to use the paste() function:\n\nquadrats &lt;- paste(\"Q\", 1:10, sep = \"\")\nquadrats\n\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n\nThis can be useful for naming vector elements. For example, we could use the names() function to name the elements of the temperature variable according to the quadrat labels.\n\nnames(temperature) &lt;- quadrats\ntemperature\n\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n\n\nThe paste() function can also be used in conjunction with other functions to generate lists of labels. For example, we could combine a vector in which the letters A, B, C, D and E (generated with the LETTERS constant) are each repeated twice consecutively (using the rep() function) with a vector that contains a 1 and a 2 to produce a character vector that labels sites in which the quadrats may have occurred.\n\nsite &lt;- paste(rep(LETTERS[1:5], each = 2), 1:2, sep = \"\")\nsite\n\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n\nOr, with the use of pipes:\n\nsite &lt;- rep(LETTERS[1:5], each = 2) |&gt;\n  paste(1:2, sep = \"\")\nsite\n\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n\nRather than specify that the components are not separated by any character (which is what we are doing above by indicating that the separator character should be ““), there is a version of paste() that does this automatically. It is paste0().\n\nsite &lt;- rep(LETTERS[1:5], each = 2) |&gt;\n  paste0(1:2)\nsite\n\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n\n\n\n\n\n\n\nMajor vector classes\n\n\n\n\n\n\n\n\n\n\ntidy-selection\n\n\nDescription\n\n\nExamples\n\n\n\n\nBare names\n\n\nSelect columns based on their names.Columns can be excluded by prepending the name with a negative sign (-).\n\n\n\nselect(data, Var1)\n\n\nselect(data, Var1, Var2)\n\n\nselect(data, c(Var1, Var2))\n\n\nselect(data, -Var1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVector class\nExample\n\n\n\n\ninteger\n{r}       | |              | 2:4          | |              |\n\n\n\nc(1, 3, 9)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHeader 1\nHeader 2\nHeader 3\n\n\n\n\nCell 1\nCell 2\nCell 3\n\n\nCell 4\nCell 5\nCell 6\n\n\n{.cell .r code}\n\n\n\n\n{r} | | # Your R code here | | # This code will be executed and results will be inserted in the table | |"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ReefCloud R/Statistics resources",
    "section": "",
    "text": "This is some text I apologize in advance, this tutorial requires quite a bit of explaining and context before it can get into the code…. Good data manipulation is an art form that requires the use of many specific tools (functions) and expert data manipulation comes from the integration of these tools together. Therefore it is necessary to have an overview of the tool set before investigating any single tool."
  },
  {
    "objectID": "index.html#section-2a",
    "href": "index.html#section-2a",
    "title": "ReefCloud R/Statistics resources",
    "section": "2.1 Section 2a",
    "text": "2.1 Section 2a"
  }
]