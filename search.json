[
  {
    "objectID": "01_introduction_to_r.html",
    "href": "01_introduction_to_r.html",
    "title": "Introduction to R",
    "section": "",
    "text": "The latest version of an R installation binary (or source code) can be downloaded from one of the Comprehensive R Archive Network (or CRAN) mirrors. Having selected one of the (Australian) mirrors, follow one of the sets of instructions below (depending on your operating system).\n\nWindowsMacOSxLinux\n\n\n\nDownload R:\n\nGo to the CRAN R-project website https://cran.r-project.org/ and click on “Download R for Windows”.\nSelect the “base” subdirectory\nSelect the “Download R-X.X.X for Windows” option (where X.X.X are a series of version and release numbers) to download.\n\nRun the installer: Double-click the downloaded .exe file and follow the installation wizard. Accept the default settings unless you have specific needs.\nOptional: Set R as the default: Check the checkbox to set R as the default for R scripts during installation. This allows you to run R scripts by double-clicking them.\nVerify installation:\n\nOpen a new command prompt (Start &gt; Run &gt; cmd) and type R. If the R console opens, the installation was successful.\nAlternatively, search for R in the Start menu\n\n\n\n\n\nDownload R:\n\nGo to the CRAN R-project website (https://cran.r-project.org/) and click on “Download R for macOS”.\nChoose the latest stable version that is appropriate for your architecture.\n\nOpen the disk image: Double-click the downloaded .pkg file and drag the R application icon to your Applications folder.\nVerify installation:\n\nOpen Terminal: Go to Applications &gt; Utilities and open Terminal.\nType R in the Terminal window. If the R console opens, the installation was successful.\n\n\n\n\n\nOpen Terminal: You can access Terminal through your application launcher or search bar.\nInstall R: The commands vary slightly depending on your Linux distribution. Here are common examples:\n\nDebian/Ubuntu: sudo apt install r-base\nFedora/CentOS: sudo yum install R\nArch Linux: sudo pacman -S R\n\n**Verify installation:* Type R in the Terminal window. If the R console opens, the installation was successful."
  },
  {
    "objectID": "01_introduction_to_r.html#the-r-environment-and-command-line",
    "href": "01_introduction_to_r.html#the-r-environment-and-command-line",
    "title": "Introduction to R",
    "section": "2.1 The R environment and command line",
    "text": "2.1 The R environment and command line\nUpon opening R, you are presented with the R Console along with the command prompt (&gt;). R is a command driven application (as opposed to a ‘point-and-click’ application) and despite the steep learning curve, there are many very good reasons for this.\nCommands that you type are evaluated once the Enter key has been pressed\nEnter the following command (5+1) at the command prompt (&gt;);\n\n5+1\n\n[1] 6\n\n\n\n\n\n\n\n\nNote\n\n\n\nI have suppressed the command prompt (&lt;) from almost all code blocks throughout these workshop and tutorial series to make it easier for you to cut and paste code into your own scripts or directly into R.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn this tutorial series, the R code to be entered appears to the right hand side of the vertical bar. The number of the left side of the bar is a line number. For single line code snippets, such as the example above, line numbers are not necessary. However, for multi-line code snippets, line numbers help for identifying and describing different parts of the code.\n\n\nThe above R code evaluates the command five plus one and returns the result (six).. The [1] before the 6 indicates that the object immediately to its right is the first element in the returned object. In this case there is only one object returned. However, when a large set of objects (e.g. numbers) are returned, each row will start with an index number thereby making it easier to count through the elements.\n\n\n\n\n\n\nImportant definitions\n\n\n\n\n\n\nObject\n\nAs an object oriented language, everything in R is an object. Data, functions even output are objects.\n\nVector\n\nA collection of one or more objects of the same type (e.g. all numbers or all characters).\n\nFunction\n\nA set of instructions carried out on one or more objects. Functions are typically wrappers for a sequence of instructions that perform specific and common tasks.\n\nParameter\n\nThe kind of information passed to a function.\n\nArgument\n\nThe specific information passed to a function.\n\nOperator\n\nA symbol that has a pre-defined meaning. Familiar operators include + - * and /.\n\nAssignment operators\n\n&lt;- Assigning a name to an object (left to right)\n\n\n-&gt; Assigning a name to an object (right to left)\n\n\n= Used when defining and specifying function arguments\n\nLogical operators (return TRUE or FALSE)\n\n&lt; Less than\n\n\n&gt; Greater than\n\n\n&lt;= Less than or equal\n\n\n&gt;= Greater than or equal\n\n\n== Is the left hand side equal to the right hand side (a query)\n\n\n!= Is the left hand side NOT equal to the right hand side (a query)\n\n\n&& Are BOTH left hand and right hand conditions TRUE\n\n\n|| Are EITHER the left hand OR right hand conditions TRUE\n\nPipe operator\n\n|&gt; piping the output of one operation to the input of the next\n\n\n\n\n\n\n2.1.1 Expressions, Assignment and Arithmetic\nInstead of evaluating a statement and printing the result directly to the console, the results of evaluations can be stored in an object via a process called ‘Assignment’. Assignment assigns a name to an object and stores the result of an evaluation in that object. The contents of an object can be viewed (printed) by typing the name of the object at the command prompt and hitting Enter.\n\nvar1 &lt;- 2 + 3\nvar1\n\n[1] 5\n\n\nOn line 1 above, the name var1 was assigned to the result of the sum of 2 and 3. On line 2, the contents of this object are printed to the screen.\nA single command (statement) can spread over multiple lines. If the Enter key is pressed before R considers the statement complete, the next line in the console will begin with the prompt + indicating that the statement is not complete. For this example, I will include the command prompt in order to demonstrate the above point.\n\n&gt; var2 &lt;-\n+   2 + 3\n&gt; var2\n\n[1] 5\n\n\nWhen the contents of an object are numbers, standard arithmetic applies;\n\nvar2 - 1\n\n[1] 4\n\nans1 &lt;- var1 * var2\nans1\n\n[1] 25\n\n\n\n\n\n\n\n\nTip\n\n\n\nGenerally, spaces are ignored in R. Hence, the above and the following are both equally valid.\n\nans1&lt;-var1*var2\nans1\n\n[1] 25\n\n\nNevertheless, the former version (with spaces) is much more readable.\n\n\nCompatible objects can be concatenated (joined together) to create objects with multiple entries. Object concatenation can be performed using the c() function.\n\nc(1, 2, 6)\n\n[1] 1 2 6\n\nc(var1, var2)\n\n[1] 5 5\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn both examples above, objects were not assigned names. As a result, the expressions were evaluated and directly printed to the consol without being stored in any way. Doing so is useful for experimenting, however as the results are not stored, they cannot be used in subsequent actions.\n\n\nIn addition to the typical addition, subtraction, multiplication and division operators, there are a number of special operators, the simplest of which are the quotient or integer divide operator (%/%) and the remainder or modulus operator (%%).\n\n7 / 3\n\n[1] 2.333333\n\n7 %/% 3\n\n[1] 2\n\n7 %% 3\n\n[1] 1\n\n\n\n\n2.1.2 Operator precedence\nThe rules of operator precedence are listed (highest to lowest) in the following table. Additionally, expressions within parentheses ‘()’ always have highest precedence.\n\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n[ [[\nindexing\n\n\n::\nnamespace\n\n\n$\ncomponent\n\n\n^\nexponentiation (evaluated right to left)\n\n\n-\n+ sign (unary)\n\n\n:\nsequence\n\n\n%special%\nspecial operators (e.g. %/%, %%, %*%, %in%)\n\n\n* /\nmultiplication and division\n\n\n+\n- addition and subtraction\n\n\n&gt; &lt; &gt;= &lt;= == !=\nordering and comparison\n\n\n!\nlogical negation (not)\n\n\n& &&\nlogical AND\n\n\n| ||\nlogical OR\n\n\n~\nformula\n\n\n-&gt; -&gt;&gt;\nassignment (left to right)\n\n\n=\nargument assignment (right to left)\n\n\n&lt;- &lt;&lt;-\nassignment (right to left)\n\n\n?\nhelp\n\n\n\n\n\n2.1.3 Command history\nEach time a command is entered at the R command prompt, the command is also added to a list known as the command history. The up and down arrow keys scroll backward and forward respectively through the session’s command history list and place the top most command at the current R command prompt. Scrolling through the command history enables previous commands to be rapidly re-executed, reviewed or modified and executed.\n\n\n2.1.4 Object names\nEverything created within R are objects. Objects are programming constructs that not only store values (the visible part of an object), they also define other properties of the object (such as the type of information contained in the object) and sometimes they also define certain routines that can be used to store, retrieve and manipulate data within the object.\nImportantly, all objects within R must have unique names to which they can be referred. Names given to any object in R can comprise virtually any sequence of letters and numbers providing that the following rules are adhered to:\n\nNames must begin with a letter (names beginning with numbers or operators are not permitted)\nNames cannot contain the following characters; space , - + * / # % & [ ] { } ( ) ~\n\nWhilst the above rules are necessary, the following naming conventions are also recommended:\n\nonly use lowercase letters and numbers\nuse underscores (_) to separate words (e.g. snake case)\ntry to use names that are both concise and meaningful.\n\nnames should reflect the content of the object. One of the powerful features of R is that there is virtually no limit to the number of objects (variables, datasets, results, models, etc) that can be in use at a time. However, without careful name management, objects can rapidly become misplaced or ambiguous. Therefore, the name of an object should reflect what it is, and what has happened to it. For example, the name log_fish_wts might be given to an object that contains log transformed fish weights. Moreover, many prefer to prefix the object name with a lowercase letter that denotes the type of data containing in the object. For example, d_mean_head_length might indicate that the object contains the mean head lengths stored as a double floating point (real numbers).\nalthough there are no restrictions on the length of names, shorter names are quicker to type and provide less scope for typographical errors and are therefore recommended (of course within the restrictions of the point above).\n\nwhere possible, avoid using names of common predefined functions and variables as this can provide a source of confusion for both you and R. For example, to represent the mean of a head length variable, use something like mean_head_length rather than mean (which is the name of a predefined function within R that calculates the mean of a set of numbers)."
  },
  {
    "objectID": "01_introduction_to_r.html#r-sessions-and-workspaces",
    "href": "01_introduction_to_r.html#r-sessions-and-workspaces",
    "title": "Introduction to R",
    "section": "2.2 R Sessions and Workspaces",
    "text": "2.2 R Sessions and Workspaces\nA number of objects have been created in the current session (a session encapsulates all the activity since the current instance of the R application was started). To review the names of all of the objects in the users current workspace (storage of user created objects);\n\nls()\n\n[1] \"ans1\"            \"has_annotations\" \"var1\"            \"var2\"           \n\n\nYou can also refine the scope of the ls() function to search for object names that match a pattern:\n\nls(pat = \"var\")\n\n[1] \"var1\" \"var2\"\n\nls(pat = \"a*1\")\n\n[1] \"ans1\" \"var1\"\n\n\nThe longer the session is running, the more objects will be created resulting in a very cluttered workspace. Unneeded objects can be removed using the rm() function. The rm() function only performs a side effect (deletes objects), if the function succeeds, it does not return any output. If it does return anything, it will be a warning or error.\n\nrm(var1, var2)   #remove the VAR1 and VAR2 objects\nrm(list = ls())  #remove all user defined objects\n\n\n\n\n\n\n\nNote\n\n\n\nIn the above examples, comments were appended to each line of code. Comments begin with a hash (#) character. Anything that follows a hash character will be ignored (until the end of the line).\nComments provide a convenient way to annotate your code so as to provide more explanation and clarity as to the intention and purpose of the associated code.\n\n\n\n2.2.1 Current working directory\nThe R working directory (location from which files/data are read and written) is by default, either the location of the R executable (or execution path in Linux) or the users home directory. The current working directory can be reviewed and changed (for the session) using the getwd() function and setwd() functions respectively. Note that R uses the Unix/Linux style directory subdivision markers. That is, R uses the forward slash / in path names rather than the regular \\ of Windows.\nWhen using setwd(), you can provide either an absolute path (the full path) or a relative path (relative to the current location). Obviously, you will get a different result to me when you issue the following:\n\ngetwd()                    #review the current working directory\n\n[1] \"/home/runner/work/workshops/workshops/tut\"\n\nsetwd(\"../\")               #change to the parent directory of the current working directory\nlist.files(path = getwd()) #list all files (and directories) in the current working directory\n\n[1] \"data\"     \"docs\"     \"Makefile\" \"tut\"     \n\n\n\n\n2.2.2 Workspaces\nThroughout an R session, all objects (including loaded packages, see Section 6) that have been added are stored within the R global environment, called the workspace. Occasionally, it is desirable to save the workspace and thus all those objects (vectors, functions, etc) that were in use during a session so that they are available during subsequent sessions. This can be done using the save.image() function. Note, this will save the workspace to a file called .RData in the current working directory (usually the R startup directory), unless a file (filename and path) is supplied as an argument to the save.image() function. A previously saved workspace can be loaded by providing a full path and filename as an argument to the load() function.\nWhilst saving a workspace image can sometimes be convenient, it can also contribute greatly to organisational problems associated with large numbers of obsolete or undocumented objects. Instead, it is usually better to specifically store each of the objects you know you are going to want to have access to across sessions separately.\n\n\n2.2.3 Quitting elegantly\nTo quit R, issue the following command; Note in Windows and MacOSX, the application can also be terminated using the standard Exiting protocols.\n\nq()\n\nYou will then be asked whether or not you wish to save the current workspace. If you do, enter ‘Y’ otherwise enter ‘N’. Unless you have a very good reason to save the workspace, I would suggest that you do not. A workspace generated in a typical session will have numerous poorly named objects (objects created to temporarily store information whilst testing). Next time R starts, it could (likely will) restore this workspace thereby starting with a cluttered workspace, and becoming a potential source of confusion if you inadvertently refer to an object stored during a previous session. Moreover, if the workspace includes additional extension packages, these packages may also be loaded which will prevent them from being updated (often necessary when installing additional packages that depend on other packages)."
  },
  {
    "objectID": "01_introduction_to_r.html#functions",
    "href": "01_introduction_to_r.html#functions",
    "title": "Introduction to R",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nAs wrappers for collections of commands used together to perform a task, functions provide a convenient way of interacting with all of these commands in sequence. Most functions require one or more inputs (parameters), and while a particular function can have multiple parameters, not all are necessarily required (some could have default values). Parameters are parsed to a function as arguments comprising the name of the parameter, an equals operator and the value of the parameter. Hence, arguments are specified as name/value pairs.\nConsider the seq() function, which generates a sequence of values (a vector) according to the values of the arguments. We can see that the default version of this function has the following definition:\n\nstr(seq.default)\n\nfunction (from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, \n    along.with = NULL, ...)  \n\n\n\nif the seq() function is called without any arguments (e.g. seq()), it will return a single number 1. Using the default arguments for the function, it returns a vector starting at 1 (from   = 1), going up to 1 (to = 1) and thus having a length of 1.\nwe can alter this behavior by specifically providing values for the named arguments. The following generates a sequence of numbers from 2 to 10 incrementing by 1 (default):\n\nseq(from = 2, to = 10)\n\n[1]  2  3  4  5  6  7  8  9 10\n\n\nthe following generates a sequence of numbers from 2 to 10 incrementing by 2:\n\nseq(from = 2, to = 10, by = 2)\n\n[1]  2  4  6  8 10\n\n\nalternatively, instead of manipulating the increment space of the sequence, we could specify the desired length of the sequence:\n\nseq(from = 2, to = 10, length.out = 3)\n\n[1]  2  6 10\n\n\nnamed arguments need not include the full name of the parameter, so long as it is unambiguous which parameter is being referred to. For example, length.out could be shortened to just l since there are no other parameters of this function that start with ‘l’:\n\nseq(from = 2, to = 10, l = 4)\n\n[1]  2.000000  4.666667  7.333333 10.000000\n\n\nparameters can also be specified as unnamed arguments provided they are in the order specified in the function definition. For example to generate a sequence of numbers from 2 to 10 incrementing by 2:\n\nseq(2, 10, 2)\n\n[1]  2  4  6  8 10\n\n\nNote, although permittable, it is more difficult to unambiguously read/interpret the code and could easily be a source of bugs.\nnamed and unnamed arguments can be mixed, just remember the above rules about parameter order and unambiguous names:\n\nseq(2, 10, l = 4)\n\n[1]  2.000000  4.666667  7.333333 10.000000"
  },
  {
    "objectID": "01_introduction_to_r.html#function-overloading-polymorphism",
    "href": "01_introduction_to_r.html#function-overloading-polymorphism",
    "title": "Introduction to R",
    "section": "2.4 Function overloading (polymorphism)",
    "text": "2.4 Function overloading (polymorphism)\nMany routines can be applied to different sorts of data. That is, they are somewhat generic. For example, we could calculate the mean (arithmetic center) of a set of numbers or we could calculate the mean of a set of dates or times. Whilst the calculations in both cases are analogous to one another, they nevertheless differ sufficiently so as to warrant separate functions.\nWe could name the functions that calculate the mean of a set of numbers and the mean of a set of dates as mean_numbers and mean_dates respectively. Unfortunately, as this is a relatively common situation, the number of functions to learn rapidly expands. And from the perspective of writing a function that itself contains such a generic function, we would have to write multiple instances of the function in order to handle all the types of data we might want to accommodate.\nTo simplify the process of applying these generic functions, R provides yet another layer that is responsible for determining which of a series of overloaded functions is likely to be applicable according to the nature of the parameters and data parsed as arguments to the function. To see this in action, type mean followed by hitting the TAB key. The TAB key is used for auto-completion and therefore this procedure lists all the objects that begin with the letters ‘mean’.\n\nmean           mean.Date      mean.default   mean.difftime  mean.POSIXct   mean.POSIXlt\n\nIn addition to an object called mean, there are additional objects that are suffixed as a ‘.’ followed by a data type. In this case, the objects mean.default, mean.Date, mean.POSIXct, mean.POSIXlt and mean.difftime are functions that respectively calculate the mean of a set of numbers, dates, times, times, time and differences. The mean function determines which of the other functions is appropriate for the data parsed and then redirects to that appropriate function. Typically, this means that it is only necessary to remember the one generic function (in this case, mean()) as the specific functions are abstracted away.\n\n# mean of a series of numbers\nmean(c(1, 2, 3, 4))\n\n[1] 2.5\n\n# create a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nsample_dates &lt;- seq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\")\n# print (view) these dates\nsample_dates\n\n[1] \"2000-02-29\" \"2000-03-07\" \"2000-03-14\" \"2000-03-21\" \"2000-03-28\"\n[6] \"2000-04-04\" \"2000-04-11\" \"2000-04-18\" \"2000-04-25\"\n\n# calculate the mean of these dates\nmean(sample_dates)\n\n[1] \"2000-03-28\"\n\n\nIn the above examples, we called the same function (mean) on both occasions. In the first instance, it was equivalent to calling the mean.default() function and in the second instance the mean.Date() function. Note that the seq() function is similarly overloaded.\nThe above example also illustrates another important behaviour of function arguments. Function calls can be nested within the arguments of other functions and function arguments are evaluated before the function runs. In this way, multiple steps to be truncated together (although for the sake of the codes’ readability and debugging, it is often better to break a problem up into smaller steps).\nIf a function argument itself contains a function (as was the case above with the from = and to = arguments, both of which called the as.Date() function which converts a character string into a date object), the value of the evaluated argument is parsed to the outside function. That is, evaluations are made from the inside to out. The above example, could have been further truncated to;\n\n# calculate the mean of a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nmean(seq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\"))\n\n[1] \"2000-03-28\"\n\n\n\n2.4.1 The pipe character\nAs we can see from the example above, nested functions can be pretty awkward to read. As of version 4.1, R has had a pipe operator. The concept of piping dates back to the early UNIX days when separate programs were chained (‘piped’) together such that the output of one program became the input of the next and so on. This enabled each program to remain relatively simple, yet by piping sequences of programs together, rather complex results could be achieved.\nSimilarly the R pipe operator (|&gt;) enables nested functions to alternatively be expressed as a chain of functions:\n\n# calculate the mean of a sequence of dates spaced 7 days apart between 29th Feb 2000 and 30th Apr 2000\nseq(from = as.Date(\"2000-02-29\"), to = as.Date(\"2000-04-30\"), by = \"7 days\") |&gt; mean()\n\n[1] \"2000-03-28\"\n\n\nTo maximise code readability, it is good form to keep lines of code short (less than 80 characters). One way to do this is to place a line break after pipe characters. Moreover, a line break after each function argument allows us to have more topical and granular comments.\n\nseq(                              #take sequence of dates\n  from = as.Date(\"2000-02-29\"),   #from the 29th Feb 2000\n  to = as.Date(\"2000-04-30\"),     #to the 30th April 2000\n  by = \"7 days\") |&gt;               #incrementing by 7 days\n  mean()                          #and calculate the mean\n\n[1] \"2000-03-28\""
  },
  {
    "objectID": "01_introduction_to_r.html#external-functions",
    "href": "01_introduction_to_r.html#external-functions",
    "title": "Introduction to R",
    "section": "2.5 External functions",
    "text": "2.5 External functions\nAs R is a scripting language (rather than a compiled language), it has the potential to be very slow (since syntax checking, machine instruction interpretation, etc must all take place at runtime rather than at compile time). Consequently, many of the functions are actually containers (wrappers) for external code (link libraries) precompiled in either C or Fortran. In this way, the environment can benefit from the flexibility of a scripting language whilst still maintaining most of the speed of a compiled language. Tutorial ? will introduce how to install and load external libraries."
  },
  {
    "objectID": "01_introduction_to_r.html#vectors",
    "href": "01_introduction_to_r.html#vectors",
    "title": "Introduction to R",
    "section": "4.1 Vectors",
    "text": "4.1 Vectors\nVectors are a collection of one or more entries (values) of the same type (class) and are the basic storage unit in R. Vectors are one-dimensional arrays (have a single dimension - length) and can be thought of as a single column of data. Each entry in a vector has a unique index (like a row number) to enable reference to particular entries in the vector.\n\n4.1.1 Consecutive integers\nTo get a vector of consecutive integers, we can specify an expression of the form &lt;first integer&gt;:&lt;second integer&gt; where &lt;first integer&gt; and &lt;second integer&gt; represent the start and end of the sequence of integers respectively:\n\n5:10\n\n[1]  5  6  7  8  9 10\n\n5:-5\n\n [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\n\n\n\n4.1.2 The c() function\nThe c() function concatenates values together into a vector. To create a vector with the numbers 1, 4, 7, 21:\n\nc(1, 4, 7, 21)\n\n[1]  1  4  7 21\n\n\nAs an example, we could store the temperature recorded at 10 sites:\n\ntemperature &lt;- c(36.1, 30.6, 31, 36.3, 39.9, 6.5, 11.2, 12.8, 9.7, 15.9)\ntemperature\n\n [1] 36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9\n\n\nTo create a vector with the words ‘Fish’, ‘Rock’, ‘Tree’, ‘Git’:\n\nc('Fish', 'Rock', 'Tree', \"Git\")\n\n[1] \"Fish\" \"Rock\" \"Tree\" \"Git\" \n\n\n\n\n4.1.3 Regular or patterned sequences (rep())\nWe have already seen the use of the seq() function to create sequences of entries.\nSequences of repeated entries are supported with the rep() function:\n\nrep(4,5)\n\n[1] 4 4 4 4 4\n\nrep('Fish',5)\n\n[1] \"Fish\" \"Fish\" \"Fish\" \"Fish\" \"Fish\"\n\n\n\n\n4.1.4 The paste() function\nTo create a sequence of quadrat labels we could use the c() function as illustrated above, e.g.\n\nquadrats &lt;- c(\"Q1\",\"Q2\",\"Q3\",\"Q4\",\"Q5\",\"Q6\",\"Q7\",\"Q8\",\"Q9\",\"Q10\")\nquadrats\n\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n\nA more elegant way of doing this is to use the paste() function:\n\nquadrats &lt;- paste(\"Q\", 1:10, sep = \"\")\nquadrats\n\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n\nThis can be useful for naming vector elements. For example, we could use the names() function to name the elements of the temperature variable according to the quadrat labels.\n\nnames(temperature) &lt;- quadrats\ntemperature\n\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n\n\nThe paste() function can also be used in conjunction with other functions to generate lists of labels. For example, we could combine a vector in which the letters A, B, C, D and E (generated with the LETTERS constant) are each repeated twice consecutively (using the rep() function) with a vector that contains a 1 and a 2 to produce a character vector that labels sites in which the quadrats may have occurred.\n\nsite &lt;- paste(rep(LETTERS[1:5], each = 2), 1:2, sep = \"\")\nsite\n\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n\nOr, with the use of pipes:\n\nsite &lt;- rep(LETTERS[1:5], each = 2) |&gt;\n  paste(1:2, sep = \"\")\nsite\n\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n\nRather than specify that the components are not separated by any character (which is what we are doing above by indicating that the separator character should be ““), there is a version of paste() that does this automatically. It is paste0().\n\nsite &lt;- rep(LETTERS[1:5], each = 2) |&gt;\n  paste0(1:2)\nsite\n\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n\n\n\n\n\n\n\nMajor vector classes\n\n\n\n\n\n\n\n\n\n\nVector class\n\n\nExamples\n\n\n\n\n\n\ninteger(whole numbers)\n\n\n\n2:4\n\n[1] 2 3 4\n\nc(1, 3, 9)\n\n[1] 1 3 9\n\n\n\n\n\n\nnumeric(real numbers)\n\n\n\nc(8.4, 2.1)\n\n[1] 8.4 2.1\n\n\n\n\n\n\ncharacter(letters)\n\n\n\nc('A', 'ABC', 'def')\n\n[1] \"A\"   \"ABC\" \"def\"\n\n\n\n\n\n\nlogical(TRUE or FALSE)\n\n\n\n2:4 == 3\n\n[1] FALSE  TRUE FALSE\n\n\n\n\n\n\ndate(dates)\n\n\n\nc(as.Date(\"2000-02-29\"), as.Date(\"29/02/2000\",\"%d/%m/%Y\"))\n\n[1] \"2000-02-29\" \"2000-02-29\"\n\n\n\n\n\n\nPOSIXlt(date/time)\n\n\n\nstrptime('2011-03-27 01:30:00', format='%Y-%m-%d %H:%M:%S')\n\n[1] \"2011-03-27 01:30:00 UTC\"\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.5 Factors\nFactors are more than a vector of characters. Factors have additional properties that are utilized during statistical analyses and graphical procedures. To illustrate the difference, we will create a vector to represent a categorical variable indicating the level of shading applied to 10 quadrats. Firstly, we will create a character vector:\n\nshade &lt;- rep(c(\"no\", \"full\"), each = 5)\nshade\n\n [1] \"no\"   \"no\"   \"no\"   \"no\"   \"no\"   \"full\" \"full\" \"full\" \"full\" \"full\"\n\n\nNow we convert this into a factor:\n\nshade &lt;- factor(shade)\nshade\n\n [1] no   no   no   no   no   full full full full full\nLevels: full no\n\n\nNotice the additional property (Levels) at the end of the output. Notice also that unless specified otherwise, the levels are ordered alphabetically. Whilst this does not impact on how the data appear in a vector, it does effect some statistical analyses, their interpretations as well as some tabular and graphical displays. If the alphabetical ordering does not reflect the natural order of the data, it is best to reorder the levels whilst defining the factor:\n\nshade &lt;- factor(shade, levels = c(\"no\", \"full\"))\nshade\n\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n\n\nA more convenient way to create a balanced (equal number of replicates) factor is to use the gl() function. To create the shading factor from above:\n\nshade &lt;- gl(n = 2, k = 5, length = 10, labels = c(\"no\", \"full\"))\nshade\n\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n\n\n\n\n4.1.6 Matrices\nMatrices have two dimensions (length and width). The entries (which must be all of the same length and type - class) are in rows and columns.\nWe could arrange the vector of shading into two columns:\n\nmatrix(temperature, nrow = 5)\n\n     [,1] [,2]\n[1,] 36.1  6.5\n[2,] 30.6 11.2\n[3,] 31.0 12.8\n[4,] 36.3  9.7\n[5,] 39.9 15.9\n\n\nSimilarly, We could arrange the vector of shading into two columns:\n\nmatrix(shade, nrow = 5)\n\n     [,1] [,2]  \n[1,] \"no\" \"full\"\n[2,] \"no\" \"full\"\n[3,] \"no\" \"full\"\n[4,] \"no\" \"full\"\n[5,] \"no\" \"full\"\n\n\nAs another example, we could store the X,Y coordinates for five quadrats within a grid. We start by generating separate vectors to represent the X and Y coordinates and then we bind them together using the cbind() function (which combines objects by columns):\n\nx &lt;- c(16.92, 24.03, 7.61, 15.49, 11.77)\ny&lt;- c(8.37, 12.93, 16.65, 12.2, 13.12)\nxy &lt;- cbind(x, y)\nxy\n\n         x     y\n[1,] 16.92  8.37\n[2,] 24.03 12.93\n[3,]  7.61 16.65\n[4,] 15.49 12.20\n[5,] 11.77 13.12\n\n\nWe could alternatively combine by rows using the rbind() function\n\nrbind(x, y)\n\n   [,1]  [,2]  [,3]  [,4]  [,5]\nx 16.92 24.03  7.61 15.49 11.77\ny  8.37 12.93 16.65 12.20 13.12\n\n\nWe could even alter the row names using an inbuilt vector of uppercase letters:\n\nrownames(xy) &lt;- LETTERS[1:5]\nxy\n\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\n\n\nImportantly, all entries in a matrix must be of the same type. That is, they must all be numeric, or all be characters etc. If we attempt to mix a combination of data types in a matrix, then the data will all be converted into a type that can accommodate all the data. For example, if we attempt to bind together the numeric temperature data and the character site data into a matrix, then the result will be a matrix of characters (since while it is possible to covert numbers to strings, in this case the reverse is not possible).\n\ncbind(temperature, site)\n\n    temperature site\nQ1  \"36.1\"      \"A1\"\nQ2  \"30.6\"      \"A2\"\nQ3  \"31\"        \"B1\"\nQ4  \"36.3\"      \"B2\"\nQ5  \"39.9\"      \"C1\"\nQ6  \"6.5\"       \"C2\"\nQ7  \"11.2\"      \"D1\"\nQ8  \"12.8\"      \"D2\"\nQ9  \"9.7\"       \"E1\"\nQ10 \"15.9\"      \"E2\"\n\n\nOn the other hand, if we attempt to bind together the numeric temperature data and the factor shade data into a matrix, then the result will be a matrix of numbers (recall that factors are internally stored as integers, yet they have a levels property that acts rather like a lookup key).\n\ncbind(temperature, shade)\n\n    temperature shade\nQ1         36.1     1\nQ2         30.6     1\nQ3         31.0     1\nQ4         36.3     1\nQ5         39.9     1\nQ6          6.5     2\nQ7         11.2     2\nQ8         12.8     2\nQ9          9.7     2\nQ10        15.9     2\n\n\n\n\n4.1.7 Lists\nLists provide a way to group together multiple objects of different type and length. For example, whilst the contents of any single vector or matrix must all be of the one type and length (e.g. all numeric or all character), a list can contain any combination of vectors, matrices, scalars and of any type. Furthermore, the objects contained in a list do not need to be of the same lengths (c.f data frames). The output of most analyses are returned as lists.\nAs an example, we could group together the previously created isolated vectors and matrices into a single object that encapsulates the entire experiment:\n\nexperiment &lt;- list(\n  site = site,\n  quadrats = quadrats,\n  coordinates = xy,\n  shade = shade,\n  temperature = temperature\n)\nexperiment\n\n$site\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n$quadrats\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n$coordinates\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\n\n$shade\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n\n$temperature\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n\n\nLists can be thought of as a set of objects bound into a single container. In the example above, the list object experiment contains a copy of the site, quadrats, coordinates, shade and temperature objects.\nImportantly, once a list has been created the objects within the list are not linked in any way to the original objects from which the list is formed. Consequently, any changes made to (for example) the temperature object will not be reflected in the content of the temperature object within the experiment list.\nTo access an object within a list, the $ operator is used as such:\n\nexperiment$temperature\n\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n\n\n\n\n4.1.8 Dataframes - data sets\nRarely are single biological variables collected in isolation. Rather, data are usually collected in sets of variables reflecting investigations of patterns between and/or among the different variables. Consequently, data sets are best organized into matrices of variables (vectors) all of the same lengths yet not necessarily of the same type. Hence, neither lists nor matrices represent natural storages for data sets. This is the role of data frames which are used to store a set of vectors of the same length (yet potentially different types) in a rectangular matrix.\nData frames are generated by combining multiple vectors together such that each vector becomes a separate column in the data frame. For a data frame to faithfully represent a data set, the sequence in which observations appear in the vectors must be the same for each vector, and each vector should have the same number of observations. For example, the first, second, third…etc entries in each vector must represent respectively, the observations collected from the first, second, third…etc sampling units.\nSince the focus of these tutorials is on the exploration, analysis and summary of data sets, and data sets are accommodated in R by data frames, the generation, importation, exportation, manipulation and management of data frames receives extensive coverage in many other subsequent tutorials.\nAs an simple example of a data frame, we could again group together the previously created isolated vectors into a single object that encapsulates a data set:\n\ndata &lt;- data.frame(\n  site = site,\n  quadrats = quadrats,\n  shade = shade,\n  temperature = temperature\n)\ndata\n\n    site quadrats shade temperature\nQ1    A1       Q1    no        36.1\nQ2    A2       Q2    no        30.6\nQ3    B1       Q3    no        31.0\nQ4    B2       Q4    no        36.3\nQ5    C1       Q5    no        39.9\nQ6    C2       Q6  full         6.5\nQ7    D1       Q7  full        11.2\nQ8    D2       Q8  full        12.8\nQ9    E1       Q9  full         9.7\nQ10   E2      Q10  full        15.9"
  },
  {
    "objectID": "01_introduction_to_r.html#object-information",
    "href": "01_introduction_to_r.html#object-information",
    "title": "Introduction to R",
    "section": "5.1 Object information",
    "text": "5.1 Object information\nAs indicated earlier, everything in R is an object. All objects have a type or class that encapsulates the sort of information stored in the object as well as determining how other functions interact with the object. The class of an object can be reviewed with the class() function:\n\nclass(temperature)\n\n[1] \"numeric\"\n\nclass(data)\n\n[1] \"data.frame\"\n\nclass(mean)\n\n[1] \"function\"\n\n\nThere is also a family of functions prefixed with is. that evaluate whether or not an object is of a particular class (or type) or not. The following table lists the common object query functions. All object query functions return a logical vector. Enter methods(is) for a more comprehensive list.\n\n\n\n\n\nFunction class\n\n\nReturns TRUE\n\n\nExamples\n\n\n\n\n\n\nis.numeric(x)\n\n\nif all elements of x are numeric or integers\n\n\n\nis.numeric(c(1, -3.5, temperature))\n\n[1] TRUE\n\n\n\n\n\n\nis.null(x)\n\n\nif x is null (the object has no length)\n\n\n\nis.null(NULL)\n\n[1] TRUE\n\n\n\n\n\n\nis.logical(x)\n\n\nif all elements of x are logical\n\n\n\nis.logical(c(TRUE, FALSE, 1))\n\n[1] FALSE\n\n\n\n\n\n\nis.character(x)\n\n\nif all elements of x are character strings\n\n\n\nis.character(c(\"A\", \"Plant\", quadrats))\n\n[1] TRUE\n\n\n\n\n\n\n\nis.vector(x)\n\n\nif the object x is a vector (has only a single dimension). Returns FALSE if object has attributes other than ‘names’.\n\n\nis.vector(temperature)\n\n[1] TRUE\n\n\n\n\n\n\nis.factor(x)\n\n\nif the object x is a factor\n\n\n\nis.factor(shade)\n\n[1] TRUE\n\n\n\n\n\n\nis.matrix(x)\n\n\nif the object x is a matrix (two dimensions, yet not adata.frame)\n\n\n\nis.matrix(xy)\n\n[1] TRUE\n\n\n\n\n\n\nis.list(x)\n\n\nif the object x is a list\n\n\n\nis.list(experiment)\n\n[1] TRUE\n\n\n\n\n\n\nis.data.frame(x)\n\n\nif the object x is a data.frame\n\n\n\nis.data.frame(data)\n\n[1] TRUE\n\n\n\n\n\n\nis.na(x)\n\n\nfor each missing (NA) element in x\n\n\n\nis.na(c(NA, 2))\n\n[1]  TRUE FALSE\n\n\n\n\n\n\n!\n\n\n(‘not’) operator as a prefix converts the above functions into ‘is.not’\n\n\n\n!is.factor(data)\n\n[1] TRUE\n\n\n\n\n\n\n\n\n5.1.1 Attributes\nMany R objects also have a set of attributes, the number and type of which are specific to each class of object. For example, a matrix object has a specific number of dimensions as well as row and column names. The attributes of an object can be viewed using the attributes() function:\n\nattributes(xy)\n\n$dim\n[1] 5 2\n\n$dimnames\n$dimnames[[1]]\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\n$dimnames[[2]]\n[1] \"x\" \"y\"\n\n\nSimilarly, the attr() function can be used to view and set individual attributes of an object, by specifying the name of the object and the name of the attribute (as a character string) as arguments. For example:\n\nattr(xy, \"dim\")\n\n[1] 5 2\n\nattr(xy, \"description\") &lt;- \"coordinates of quadrats\"\nxy\n\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\nattr(,\"description\")\n[1] \"coordinates of quadrats\"\n\n\nNote that in the above example, the attribute ‘description’ is not a in-built attribute of a matrix. When a new attribute is set, this attribute is displayed along with the object. This provides a useful way of attaching a description (or other metadata) to an object, thereby reducing the risks of the object becoming unfamiliar."
  },
  {
    "objectID": "01_introduction_to_r.html#object-conversion",
    "href": "01_introduction_to_r.html#object-conversion",
    "title": "Introduction to R",
    "section": "5.2 Object conversion",
    "text": "5.2 Object conversion\nObjects can be converted or coerced into other objects using a family of functions with a as. prefix. Note that there are some obvious restrictions on these conversions as most objects cannot be completely accommodated by all other object types, and therefore some information (such as certain attributes) may be lost or modified during the conversion. Objects and elements that cannot be successfully coerced are returned as NA. The following table lists the common object coercion functions. Use methods(as) for a more comprehensive list.\n\n\n\n\n\nFunction\n\n\nConverts object to\n\n\n\n\n\n\nas.numeric(x)\n\n\na numeric vector (‘integer’ or ‘real’). Factors converted to integers.\n\n\n\n\nas.null(x)\n\n\na NULL\n\n\n\n\nas.logical(x)\n\n\na logical vector. A values of &gt;1 converted to TRUE otherwise FALSE.\n\n\n\n\nas.character(x)\n\n\na character (string) vector.\n\n\n\n\nas.vector(x)\n\n\na vector. All attributes (including names) are removed.\n\n\n\n\nas.factor(x)\n\n\na factor. This is an abbreviated (with respect to its argument set) version of the factor() function.\n\n\n\n\nas.matrix(x)\n\n\na matrix. Any non-numeric elements result in all matrix elements being converted to characters.\n\n\n\n\nas.list(x)\n\n\na list\n\n\n\n\nas.data.frame(x)\n\n\na data.frame. Matrix columns and list items are converted into separate vectors of the dataframe and character vectors are converted into factors. All previous attributes are removed.\n\n\n\n\nas.date(x)\n\n\na date"
  },
  {
    "objectID": "01_introduction_to_r.html#indexing",
    "href": "01_introduction_to_r.html#indexing",
    "title": "Introduction to R",
    "section": "5.3 Indexing",
    "text": "5.3 Indexing\nIndexing is the means by which data are filtered (subsetted) to include and exclude certain entries.\n\n5.3.1 Vector indexing\nSubsets of vectors are produced by appending an index vector (inclosed in square brackets []) to a vector name. There are four common forms of vector indexing used to extract a subset of vectors:\n\nVector of positive integers - a set of integers that indicate which elements of the vector should be included:\n\ntemperature[2]\n\n  Q2 \n30.6 \n\ntemperature[2:5]\n\n  Q2   Q3   Q4   Q5 \n30.6 31.0 36.3 39.9 \n\ntemperature[c(1, 5, 6, 9)]\n\n  Q1   Q5   Q6   Q9 \n36.1 39.9  6.5  9.7 \n\n\nVector of negative integers - a set of integers that indicate which elements of the vector should be excluded:\n\ntemperature[-2]\n\n  Q1   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n\ntemperature[c(1, 5, 6, 9) * -1]\n\n  Q2   Q3   Q4   Q7   Q8  Q10 \n30.6 31.0 36.3 11.2 12.8 15.9 \n\n\nVector of character strings (referencing names) - for vectors whose elements have been named, a vector of names can be used to select elements to include:\n\ntemperature[\"Q1\"]\n\n  Q1 \n36.1 \n\ntemperature[c(\"Q1\", \"Q4\")]\n\n  Q1   Q4 \n36.1 36.3 \n\n\nVector of logical values - a vector of logical values (TRUE or FALSE) the same length as the vector being subsetted. Entries corresponding to a logical TRUE are included, FALSE are excluded:\n\ntemperature[temperature &lt; 15]\n\n  Q6   Q7   Q8   Q9 \n 6.5 11.2 12.8  9.7 \n\ntemperature[shade == \"no\"]\n\n  Q1   Q2   Q3   Q4   Q5 \n36.1 30.6 31.0 36.3 39.9 \n\ntemperature[temperature &lt; 34 & shade == \"no\"]\n\n  Q2   Q3 \n30.6 31.0 \n\ntemperature[temperature &lt; 10 | shade == \"no\"]\n\n  Q1   Q2   Q3   Q4   Q5   Q6   Q9 \n36.1 30.6 31.0 36.3 39.9  6.5  9.7 \n\n\n\n\n\n5.3.2 Matrix indexing\nSimilar to vectors, matrices can be indexed using positive integers, negative integers, character strings and logical vectors. However, whereas vectors have a single dimension (length), matrices have two dimensions (length and width). Hence, indexing needs to reflect this. It is necessary to specify both the row and column number. Matrix indexing takes of the form of [row.indices, col.indices] where row.indices and col.indices respectively represent sequences of row and column indices. If a row or column index sequence is omitted, it is interpreted as the entire row or column respectively.\n\nxy[3, 2]\n\n[1] 16.65\n\nxy[3, ]\n\n    x     y \n 7.61 16.65 \n\nxy[, -2]\n\n    A     B     C     D     E \n16.92 24.03  7.61 15.49 11.77 \n\nxy[\"A\", 1:2]\n\n    x     y \n16.92  8.37 \n\nxy[, \"x\"]\n\n    A     B     C     D     E \n16.92 24.03  7.61 15.49 11.77 \n\nxy[xy[, \"x\"] &gt; 12, ]\n\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nD 15.49 12.20\n\n\nIf you think that last example looks awkward you would not be alone. In a later tutorial, I will introduce an alternative way of manipulating data for data frames.\n\n\n5.3.3 List indexing\nLists consist of collections of objects that need not be of the same size or type. The objects within a list are indexed by appending an index vector (enclosed in single or double square brackets, [] or [[]]), to the list name. Single square brackets provide access to multiple list items (returned as a list), whereas double square brackets provide access to individual list items (returned according to the type of object represented by the list item). A single object within a list can also be referred to by appending a string character ($) followed by the name of the object to the list names (e.g. list$object). The elements of objects within a list are indexed according to the object type. Vector indices to objects within other objects (lists) are placed within their own square brackets outside the list square brackets: Recall the experiment list we generated earlier.\n\nexperiment\n\n$site\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n$quadrats\n [1] \"Q1\"  \"Q2\"  \"Q3\"  \"Q4\"  \"Q5\"  \"Q6\"  \"Q7\"  \"Q8\"  \"Q9\"  \"Q10\"\n\n$coordinates\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\n\n$shade\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n\n$temperature\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n\n\nThe following examples illustrate the common ways to subset (index) lists.\n\nA vector of positive numbers (single brackets) - that indicate which list items should be included:\n\nexperiment[c(1,3)]\n\n$site\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n$coordinates\n      x     y\nA 16.92  8.37\nB 24.03 12.93\nC  7.61 16.65\nD 15.49 12.20\nE 11.77 13.12\n\n\nA single positive number (double brackets) - that indicates which list item should be included:\n\nexperiment[[1]]\n\n [1] \"A1\" \"A2\" \"B1\" \"B2\" \"C1\" \"C2\" \"D1\" \"D2\" \"E1\" \"E2\"\n\n\nA single character string (double brackets) - that indicates which list item should be included:\n\nexperiment[['temperature']]\n\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n36.1 30.6 31.0 36.3 39.9  6.5 11.2 12.8  9.7 15.9 \n\n\nExtract the first element of each list item - returned as a matrix:\n\nsapply(experiment, \"[\" ,1)\n\n          site       quadrats    coordinates          shade temperature.Q1 \n          \"A1\"           \"Q1\"        \"16.92\"            \"1\"         \"36.1\" \n\n##notice that only one element of the coordinate pair is included\n##OR when the list items are not vectors\ndo.call(cbind, experiment)[1, ]\n\nWarning in (function (..., deparse.level = 1) : number of rows of result is not\na multiple of vector length (arg 1)\n\n\n       site    quadrats           x           y       shade temperature \n       \"A1\"        \"Q1\"     \"16.92\"      \"8.37\"         \"1\"      \"36.1\""
  },
  {
    "objectID": "01_introduction_to_r.html#pattern-matching-and-replacement",
    "href": "01_introduction_to_r.html#pattern-matching-and-replacement",
    "title": "Introduction to R",
    "section": "5.4 Pattern matching and replacement",
    "text": "5.4 Pattern matching and replacement\nAn important part of filtering is the ability to detect patterns on which to base selections or exclusions. Numerical and categorical filtering rules are generally fairly straight forward, however complex filtering rules can also be devised from character vectors. Furthermore, the ability to search and replace character strings within a character vector can also be very useful.\n\n5.4.1 grep - index of match\nThe grep() function searches within a vector for matches to a pattern and returns the index of all matching entries.\n\n## get the indexes of elements of the site vector that contain an 'A' \ngrep(pattern = \"A\", experiment$site)\n\n[1] 1 2\n\n## use the results of the grep as indexes to select only those 'site'\n## values that contain an 'A'\nexperiment$site[grep(pattern = \"a\", experiment$site)]\n\ncharacter(0)\n\n\nThe pattern can comprise any valid regular expression and is therefore very flexible:\n\n## get the indexes of values of the 'site' vector within the `data`\n## dataframe that contain either an 'A', 'B' or 'C' followed by a '1'\ngrep(\"[a-c]1\", data$site)\n\ninteger(0)\n\n## select only those rows of the `data` dataframe that correspond to a\n## 'site' value of either an 'A', 'B' or 'C' followed by a '1'\ndata[grep(\"[a-c]1\", data$site), ]\n\n[1] site        quadrats    shade       temperature\n&lt;0 rows&gt; (or 0-length row.names)\n\n\n\n\n5.4.2 regexpr - position and length of match\nRather than return the indexes of matching entries, the regexpr() function returns the position of the match within each string as well as the length of the pattern within each string (-1 values correspond to entries in which the pattern is not found).\n\naust &lt;- c(\"adelaide\", \"brisbane\", \"canberra\", \"darwin\", \"hobart\", \"melbourne\", \"perth\", \"sydney\")\naust\n\n[1] \"adelaide\"  \"brisbane\"  \"canberra\"  \"darwin\"    \"hobart\"    \"melbourne\"\n[7] \"perth\"     \"sydney\"   \n\n## get the position and length of string of characters containing an\n## 'a' and an 'e' separated by any number of characters\nregexpr(pattern=\"a.*e\", aust)\n\n[1]  1  6  2 -1 -1 -1 -1 -1\nattr(,\"match.length\")\n[1]  8  3  4 -1 -1 -1 -1 -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n\n\n\n5.4.3 gsub - pattern replacement\nThe gsub() function replaces all instances of an identified pattern within a character vector with an alternative set of characters. The similar sub() function replaces only the first instance.\n\ndata$shade\n\n [1] no   no   no   no   no   full full full full full\nLevels: no full\n\ngsub(\"no\", \"Not shaded\", data$shade)\n\n [1] \"Not shaded\" \"Not shaded\" \"Not shaded\" \"Not shaded\" \"Not shaded\"\n [6] \"full\"       \"full\"       \"full\"       \"full\"       \"full\"      \n\n\nIt is also possible to extend the functionality to accomodate perl-compatible regular expressions.\n\n## convert all the capital values entries into uppercase identify (and\n## store) all words (`\\\\w`) convert stored pattern (`\\\\1`) to uppercase\n## (`\\\\U`)\ngsub(\"(\\\\w)\", \"\\\\U\\\\1\", aust, perl = TRUE)\n\n[1] \"ADELAIDE\"  \"BRISBANE\"  \"CANBERRA\"  \"DARWIN\"    \"HOBART\"    \"MELBOURNE\"\n[7] \"PERTH\"     \"SYDNEY\"   \n\n\n\n\n5.4.4 substr - extracting substrings\nThe substr() function is used to extract parts of string (set of characters) entries within character vectors and thus is useful for making truncated labels (particularly for graphical summaries). For example, if we had a character vector containing the names of the Australian capital cities and required abbreviations (first 3 characters) for graph labels:\n\n## recall the AUST character vector that lists the Australian capital\n## cities\naust\n\n[1] \"adelaide\"  \"brisbane\"  \"canberra\"  \"darwin\"    \"hobart\"    \"melbourne\"\n[7] \"perth\"     \"sydney\"   \n\nsubstr(aust, start = 1, stop = 3)\n\n[1] \"ade\" \"bri\" \"can\" \"dar\" \"hob\" \"mel\" \"per\" \"syd\"\n\n\nAlternatively, we could use the abbreviate() function.\n\nabbreviate(aust, minlength = 3)\n\n adelaide  brisbane  canberra    darwin    hobart melbourne     perth    sydney \n    \"adl\"     \"brs\"     \"cnb\"     \"drw\"     \"hbr\"     \"mlb\"     \"prt\"     \"syd\" \n\n\n\n\n5.4.5 Value matching\nIn addition to the above matching procedures, it is possible to compare vectors via the usual set of binary operators (x&lt;y, x&gt;y, x≤y, x≥y, x==y and x!=y).\n\nshade == 'no'\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\ntemperature &gt; 32\n\n   Q1    Q2    Q3    Q4    Q5    Q6    Q7    Q8    Q9   Q10 \n TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE \n\n\nNote, that the comparisons are made in an item-wise manner. That is, item one of the right hand vector is compared to item one of the left hand vector, and item two of each vector are compared to one another and so on. If the two vectors are not of equal length, the shorter vector is recycled (that is, it returns to the start of that vector and keeps going).\n\n## Compare 'Q1' to items 1,3,5,7,9 of quadrats and compare 'Q3' to\n## items 2,4,6,8,10.\nquadrats == c('Q1','Q3')\n\n [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe very cautious when using the binary operators x==y or x!=y to compare numeric vectors as they do not allow for rounding errors or finite representation of fractions and will almost always return FALSE even for values that appear identical. As an alternative, consider using a combination of all.equal() and identical():\n\n\n\n(0.6 - 0.4) == (0.4 - 0.2)\n\n[1] FALSE\n\nall.equal((0.6 - 0.4), (0.4 - 0.2))\n\n[1] TRUE\n\nidentical(all.equal((0.6 - 0.4), (0.4 - 0.2)), TRUE)\n\n[1] TRUE\n\n\nEach of the search and replace functions listed above uses only a single search item (albeit with pattern matching that can accommodate multiple patterns). The match() function searches for the first instance of items in the lookup vector (vector of values to be matched against) within the vector to be matched (first vector) returning the index of the first instance. Similarly, the special binary operator %in% indicates whether or not (TRUE or FALSE) an item of the matching vector is contained anywhere within the first vector. This latter mechanism makes a very useful filter.\n\n## match the items within the `shade` vector against a lookup character\n## vector containing only the string of \"no\" returning the index\n## within the lookup vector\nmatch(shade,\"no\")\n\n [1]  1  1  1  1  1 NA NA NA NA NA\n\n## match the items within the shade vector against a lookup character\n## vector containing only the string of \"no\" returning the index\n## within the lookup vector\nmatch(shade,\"no\")\n\n [1]  1  1  1  1  1 NA NA NA NA NA\n\n## same match as above, yet returning a logical vector corresponding\n## to whether each item in the first vector is matched or not\nshade %in% 'no'\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n## match quadrats of 'Q1', 'Q4' and 'Q10'\nmatch(quadrats, c(\"Q1\",\"Q4\",\"Q10\"))\n\n [1]  1 NA NA  2 NA NA NA NA NA  3\n\nquadrats %in% c(\"Q1\",\"Q4\",\"Q10\")\n\n [1]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n\n## use the resulting logical vector as a filter\ndata[quadrats %in% c(\"Q1\",\"Q4\",\"Q10\"),]\n\n    site quadrats shade temperature\nQ1    A1       Q1    no        36.1\nQ4    B2       Q4    no        36.3\nQ10   E2      Q10  full        15.9"
  },
  {
    "objectID": "01_introduction_to_r.html#sorting",
    "href": "01_introduction_to_r.html#sorting",
    "title": "Introduction to R",
    "section": "5.5 Sorting",
    "text": "5.5 Sorting\nThe sort() function is used to sort vector entries in increasing (or decreasing) order.\n\nsort(temperature)\n\n  Q6   Q9   Q7   Q8  Q10   Q2   Q3   Q1   Q4   Q5 \n 6.5  9.7 11.2 12.8 15.9 30.6 31.0 36.1 36.3 39.9 \n\nsort(temperature, decreasing = TRUE)\n\n  Q5   Q4   Q1   Q3   Q2  Q10   Q8   Q7   Q9   Q6 \n39.9 36.3 36.1 31.0 30.6 15.9 12.8 11.2  9.7  6.5 \n\n\nThe order() function is used to get the position of each entry in a vector if it were sorted in increasing (or decreasing) order.\n\norder(temperature)\n\n [1]  6  9  7  8 10  2  3  1  4  5\n\norder(temperature, decreasing = TRUE)\n\n [1]  5  4  1  3  2 10  8  7  9  6\n\n\nHence the smallest entry in the temperature vector was at position (index) 6 and so on.\nThe rank() function is used to get the ranking of each entry in a vector if it were sorted in increasing (or decreasing) order.\n\nrank(temperature)\n\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n  8   6   7   9  10   1   3   4   2   5 \n\n\nIndicating that the first entry in the temperature vector was ranked eighth in increasing order. Ranks from decreasing order can be produced by then reversing the returned vector using the rev() function.\n\nrev(rank(temperature))\n\nQ10  Q9  Q8  Q7  Q6  Q5  Q4  Q3  Q2  Q1 \n  5   2   4   3   1  10   9   7   6   8 \n\n## or via pipe\nrank(temperature) |&gt; rev()\n\nQ10  Q9  Q8  Q7  Q6  Q5  Q4  Q3  Q2  Q1 \n  5   2   4   3   1  10   9   7   6   8"
  },
  {
    "objectID": "01_introduction_to_r.html#formatting-data",
    "href": "01_introduction_to_r.html#formatting-data",
    "title": "Introduction to R",
    "section": "5.6 Formatting data",
    "text": "5.6 Formatting data\n\n5.6.1 Rounding of numerical data\nThe ceiling() function rounds vector entries up to the nearest integer\n\nceiling(temperature)\n\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 37  31  31  37  40   7  12  13  10  16 \n\n\nThe floor() function rounds vector entries down to the nearest integer\n\nfloor(temperature)\n\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 36  30  31  36  39   6  11  12   9  15 \n\n\nThe trunc() function rounds vector entries to the nearest integer towards ‘0’ (zero)\n\nseq(from = -2, to = 2, by = 0.5)\n\n[1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0\n\ntrunc(seq(from = -2, to = 2, by = 0.5))\n\n[1] -2 -1 -1  0  0  0  1  1  2\n\n\nThe round() function rounds vector entries to the nearest numeric with the specified number of decimal places. Digits of 5 are rounded off to the nearest even digit.\n\nround(temperature)\n\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 36  31  31  36  40   6  11  13  10  16 \n\nround(seq(from = -2, to = 2, by = 0.5))\n\n[1] -2 -2 -1  0  0  0  1  2  2\n\nround(temperature/2.2, digits = 2)\n\n   Q1    Q2    Q3    Q4    Q5    Q6    Q7    Q8    Q9   Q10 \n16.41 13.91 14.09 16.50 18.14  2.95  5.09  5.82  4.41  7.23 \n\nround(temperature, digits = -1)\n\n Q1  Q2  Q3  Q4  Q5  Q6  Q7  Q8  Q9 Q10 \n 40  30  30  40  40  10  10  10  10  20 \n\n\n\n\n5.6.2 Notation and labelling of numeric or character data\nOccasionally (mainly for graphical displays), it is necessary to be able to adjust the other aspects of the formatting of vector entries. For example, you may wish to have numbers expressed in scientific notation (2.93e-04 rather than 0.000293) or insert commas every 3 digits left of the decimal point or even add prefixes or suffixes to numbers or words. These procedures are supported via a number of functions. The uses of each function are contrasted in the following table followed by common usage examples below.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\npaste()\nConcatenate vectors after converting into characters\n\n\nformat()\nAdjust decimal places, justification, padding and width of string and whether to use scientific notation\n\n\nformatC()\nA version of format() that is compliant with ‘C’ style formatting.\n\n\nsprintf()\nA wrapper for the ‘C’ style formatting function of the same name = provides even greater flexibility (and complexity).\n\n\n\n\npaste()\nCombine multiple elements together along with other character strings.\n\npaste(\"Quadrat\", 1:3, sep = \":\")\n\n[1] \"Quadrat:1\" \"Quadrat:2\" \"Quadrat:3\"\n\n##create a joint label for site and quadrat combinations\npaste(site, quadrats, sep = \":\")\n\n [1] \"A1:Q1\"  \"A2:Q2\"  \"B1:Q3\"  \"B2:Q4\"  \"C1:Q5\"  \"C2:Q6\"  \"D1:Q7\"  \"D2:Q8\" \n [9] \"E1:Q9\"  \"E2:Q10\"\n\n## create a formula relating temperature to quadrat, site and shade\npaste(names(data)[4], paste(names(data)[-4], collapse = \"+\"), sep = \"~\")\n\n[1] \"temperature~site+quadrats+shade\"\n\n## or more neatly\npaste(names(data)[4],\n  paste(names(data)[-4], collapse = \"+\"),\n  sep = \"~\"\n)\n\n[1] \"temperature~site+quadrats+shade\"\n\n\n\n\nformat()\nOverloaded generic function for formatting objects (particularly numeric vectors). The most prominent features include:\n\nAutomatically adding leading or trailing spaces to create equal width labels (via trim =, width = and justify = )\nApplication of scientific notation (via scientific =)\nRounding of numbers (via digits = and nsmall =)\nApplies to each column in a dataframe separately\n\n\n## create equal width strings by adding padding to the start (left\n## side) of numbers\nformat(temperature)\n\n    Q1     Q2     Q3     Q4     Q5     Q6     Q7     Q8     Q9    Q10 \n\"36.1\" \"30.6\" \"31.0\" \"36.3\" \"39.9\" \" 6.5\" \"11.2\" \"12.8\" \" 9.7\" \"15.9\" \n\n## create labels with a minimum of 2 digits to the right hand side of\n## the decimal place\nformat(temperature, nsmall = 2)\n\n     Q1      Q2      Q3      Q4      Q5      Q6      Q7      Q8      Q9     Q10 \n\"36.10\" \"30.60\" \"31.00\" \"36.30\" \"39.90\" \" 6.50\" \"11.20\" \"12.80\" \" 9.70\" \"15.90\" \n\n## create labels that are rounded numbers\nformat(temperature, digits = 1)\n\n  Q1   Q2   Q3   Q4   Q5   Q6   Q7   Q8   Q9  Q10 \n\"36\" \"31\" \"31\" \"36\" \"40\" \" 6\" \"11\" \"13\" \"10\" \"16\" \n\n## create labels that are scientific representations of the numbers\nformat(temperature, scientific = TRUE)\n\n        Q1         Q2         Q3         Q4         Q5         Q6         Q7 \n\"3.61e+01\" \"3.06e+01\" \"3.10e+01\" \"3.63e+01\" \"3.99e+01\" \"6.50e+00\" \"1.12e+01\" \n        Q8         Q9        Q10 \n\"1.28e+01\" \"9.70e+00\" \"1.59e+01\" \n\n## apply formatting rules to a dataframe (notice the left\n## justification of Shade and the number of decimal places of\n## temperature)\nformat(data, justify = \"left\", nsmall = 2)\n\n    site quadrats shade temperature\nQ1    A1      Q1   no         36.10\nQ2    A2      Q2   no         30.60\nQ3    B1      Q3   no         31.00\nQ4    B2      Q4   no         36.30\nQ5    C1      Q5   no         39.90\nQ6    C2      Q6   full        6.50\nQ7    D1      Q7   full       11.20\nQ8    D2      Q8   full       12.80\nQ9    E1      Q9   full        9.70\nQ10   E2      Q10  full       15.90\n\n\n\n\nformatC()\nSimilar to the format() function, yet also allows ‘C’ style formatting specifications:\n\n‘d’ for integers\n‘f’ for reals in the standard xxx.xxx format\n‘e’, ‘E’ for reals in the scientific (n.ddde+nn) format\n‘g’, ‘G’ for reals in the scientific (n.ddde+nn) format when it saves space to do so\n‘s’ for strings\n\n\nseq(pi, pi * 10000, length = 5)\n\n[1]     3.141593  7856.337828 15709.534064 23562.730300 31415.926536\n\n## format to integers  \nformatC(seq(pi, pi * 10000, length = 5), format = \"d\")\n\n[1] \"3\"     \"7856\"  \"15709\" \"23562\" \"31415\"\n\n## scientific notation\nformatC(seq(pi, pi * 10000, length = 5), format = \"e\", digits = 2)\n\n[1] \"3.14e+00\" \"7.86e+03\" \"1.57e+04\" \"2.36e+04\" \"3.14e+04\"\n\n## scientific notation only if it saves space\nformatC(seq(pi, pi * 10000, length = 5), format = \"g\", digits = 2)\n\n[1] \"3.1\"     \"7.9e+03\" \"1.6e+04\" \"2.4e+04\" \"3.1e+04\"\n\n## floating point format with 1000's indicators\nformatC(seq(pi, pi * 10000, length = 5), format = \"f\", big.mark = \",\", digits = 2)\n\n[1] \"3.14\"      \"7,856.34\"  \"15,709.53\" \"23,562.73\" \"31,415.93\"\n\n\n\n\nsprintf()\nSimilar to the format() function, yet also allows ‘C’ style formatting specifications:\n\n‘d’ for integers\n‘f’ for reals in the standard xxx.xxx format\n‘e’, ‘E’ for reals in the scientific (n.ddde+nn) format\n‘g’, ‘G’ for reals in the scientific (n.ddde+nn) format when it saves space to do so\n‘s’ for strings\n\n\nPI &lt;- seq(pi, pi * 10000, length = 5)\nPI\n\n[1]     3.141593  7856.337828 15709.534064 23562.730300 31415.926536\n\n## format to integers\nsprintf(\"%.0f\", PI)\n\n[1] \"3\"     \"7856\"  \"15710\" \"23563\" \"31416\"\n\n## format to two decimal places and 6 characters to the left of the\n## decimal point (right justified)\nsprintf(\"%6.2f\", PI)\n\n[1] \"  3.14\"   \"7856.34\"  \"15709.53\" \"23562.73\" \"31415.93\"\n\n## scientific notation\nsprintf(\"%e\", PI)\n\n[1] \"3.141593e+00\" \"7.856338e+03\" \"1.570953e+04\" \"2.356273e+04\" \"3.141593e+04\"\n\n## scientific notation only when it saves space\nsprintf(\"%6.2g\", PI)\n\n[1] \"   3.1\"  \"7.9e+03\" \"1.6e+04\" \"2.4e+04\" \"3.1e+04\"\n\n## concatenating strings\nsprintf(\"%s-%s\", site, quadrats)\n\n [1] \"A1-Q1\"  \"A2-Q2\"  \"B1-Q3\"  \"B2-Q4\"  \"C1-Q5\"  \"C2-Q6\"  \"D1-Q7\"  \"D2-Q8\" \n [9] \"E1-Q9\"  \"E2-Q10\"\n\nsprintf(\"%s=%.2g\", 'val', PI)\n\n[1] \"val=3.1\"     \"val=7.9e+03\" \"val=1.6e+04\" \"val=2.4e+04\" \"val=3.1e+04\"\n\nsprintf(\"%s=%6.2g\", 'val', PI)\n\n[1] \"val=   3.1\"  \"val=7.9e+03\" \"val=1.6e+04\" \"val=2.4e+04\" \"val=3.1e+04\"\n\nsprintf('%11s', sprintf(\"%s=%.2g\", 'val', PI))\n\n[1] \"    val=3.1\" \"val=7.9e+03\" \"val=1.6e+04\" \"val=2.4e+04\" \"val=3.1e+04\""
  },
  {
    "objectID": "01_introduction_to_r.html#applying-functions-repetitively",
    "href": "01_introduction_to_r.html#applying-functions-repetitively",
    "title": "Introduction to R",
    "section": "5.7 Applying functions repetitively",
    "text": "5.7 Applying functions repetitively\nAs R is a programming language, it naturally has constructs for controlling flow via looping and conditional evaluation. R’s basic control-flow constructs is the topic of another tutorial. Despite the enormous flexibility gained via the usual control-flow constructs, recall that as R is a scripting language (rather than a compiled language), it is relatively slow. In particular, repetitive tasks (such as looping though a dataframe and applying the same function to different subsets of the data) are especially inefficient.\nThere are a number of functions in R that are designed to allow the repetitive application of a function thereby replacing the need to write loops.\n\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nrep()\nDuplicates the result of a function multiple times\n\n\nreplicated()\nPerforms a function multiple times\n\n\napply()\nRepetitively apply a function over the margins of a matrix\n\n\ntapply()\nRepetitively apply a function to cells made up of unique combinations of factor levels\n\n\nlapply()\nRepetitively apply a function to the elements of a list of vector and return a list.\n\n\n\nThe replicate() function repeatedly performs the function specified in the second argument the number of times indicated by the first argument. The important distinction between the replicate() function and the rep() function described earlier, is that the former repeatedly performs the function whereas the later performs the function only once and then duplicates the result multiple times.\nSince most functions produce the same result each time they are performed, for many uses, both functions produce identical results. The one group of functions that do not produce identical results each time, are those involved in random number generation. Hence, the replicate() function is usually used in conjunction with random number generators (such as runif(), which will be described in greater detail in subsequent tutorial) to produce sets of random numbers. Consider first the difference between rep() and replicate():\n\nrep(runif(1), times = 5)\n\n[1] 0.5381136 0.5381136 0.5381136 0.5381136 0.5381136\n\nreplicate(n = 5, runif(1))\n\n[1] 0.85593810 0.19674183 0.89425953 0.09428125 0.03422838\n\n\nWhen the function being run within runif() itself produces a vector of length &gt; 1, the runif() function combines each of the vectors together as separate columns in a matrix:\n\nreplicate(n = 5, runif(5))\n\n          [,1]       [,2]      [,3]       [,4]       [,5]\n[1,] 0.8397048 0.04351905 0.2779985 0.43353184 0.05569761\n[2,] 0.5725360 0.66398603 0.9193654 0.01905352 0.90736643\n[3,] 0.3349170 0.07617351 0.8597763 0.52151425 0.69535967\n[4,] 0.4941478 0.48090416 0.1087783 0.44846413 0.06086788\n[5,] 0.3016135 0.41666847 0.4892810 0.76000424 0.48877001\n\n\n\n5.7.1 Apply functions along matrix margins\nThe apply() function applies a function to the margins (1=row margins and 2=column margins) of a matrix. For example, we might have a matrix that represents the abundance of three species of moth from three habitat types:\n\nmoth &lt;- cbind(SpA = c(25, 6, 3), SpB = c(12, 12, 3), SpC = c(7, 2, 19))\nrownames(moth) &lt;- paste(\"Habitat\", 1:3, sep = \"\")\nmoth\n\n         SpA SpB SpC\nHabitat1  25  12   7\nHabitat2   6  12   2\nHabitat3   3   3  19\n\n\nThe apply() function could be used to calculate the column means (mean abundance of each species across habitat types):\n\napply(moth, MARGIN = 2, FUN = mean)\n\n      SpA       SpB       SpC \n11.333333  9.000000  9.333333 \n\n\n\n\n5.7.2 Pivot tables\nThe tapply() function applies a function to a vector separately for each level of a factorial variable. For example, if we wanted to calculate the mean temperature for each level of the shade variable:\n\ntapply(temperature, INDEX = shade, FUN = mean)\n\n   no  full \n34.78 11.22 \n\n## calculate the mean temperature per shade and quadrat number combination\n## quadrat number is just the last digit of the quadrats vector\n## extracted via substr(site, 2, 2)\ntapply(temperature, list(shade, quadnum = substr(site, 2, 2)), mean)\n\n      quadnum\n              1        2\n  no   35.66667 33.45000\n  full 10.45000 11.73333\n\n\n\n\n5.7.3 Apply a function over a list\nThe lapply() and sapply() functions apply a function separately to each of the objects in a list and return a list and vector/matrix respectively. For example, to find out the length of each of the objects within the experiment list:\n\nlapply(experiment, length)\n\n$site\n[1] 10\n\n$quadrats\n[1] 10\n\n$coordinates\n[1] 10\n\n$shade\n[1] 10\n\n$temperature\n[1] 10\n\nsapply(experiment, length)\n\n       site    quadrats coordinates       shade temperature \n         10          10          10          10          10"
  },
  {
    "objectID": "01_introduction_to_r.html#listing-installed-packages",
    "href": "01_introduction_to_r.html#listing-installed-packages",
    "title": "Introduction to R",
    "section": "6.1 Listing installed packages",
    "text": "6.1 Listing installed packages\nThe installed.packages() function tabulates a list of all the currently installed packages available on your system along with the package path (where is resides on your system) and version number. Additional fields can be requested (including “Priority”, “Depends”, “Imports”, “LinkingTo”, “Suggests”, “Enhances”, “OS_type”, “License” and “Built”).\n\ninstalled.packages()\ninstalled.packages(fields=c(\"Package\", \"LibPath\", \"Version\", \"Depends\",\"Built\"))\n\n\n\n\n\n\n\nNote\n\n\n\nIn the above, I have intentionally supressed the output so as not to flood the output (I have a very large number of packages installed on my machine).\n\n\nYet more information can be obtained for any single package with the packageDescription() and library functions - the latter provides all the information of the former and then includes a descriptive index of all the functions and datasets defined within the package.\n\npackageDescription('MASS')\n\nPackage: MASS\nPriority: recommended\nVersion: 7.3-60\nDate: 2023-05-02\nRevision: $Rev: 3621 $\nDepends: R (&gt;= 4.0), grDevices, graphics, stats, utils\nImports: methods\nSuggests: lattice, nlme, nnet, survival\nAuthors@R: c(person(\"Brian\", \"Ripley\", role = c(\"aut\", \"cre\", \"cph\"),\n        email = \"ripley@stats.ox.ac.uk\"), person(\"Bill\", \"Venables\",\n        role = \"ctb\"), person(c(\"Douglas\", \"M.\"), \"Bates\", role =\n        \"ctb\"), person(\"Kurt\", \"Hornik\", role = \"trl\", comment =\n        \"partial port ca 1998\"), person(\"Albrecht\", \"Gebhardt\", role =\n        \"trl\", comment = \"partial port ca 1998\"), person(\"David\",\n        \"Firth\", role = \"ctb\"))\nDescription: Functions and datasets to support Venables and Ripley,\n        \"Modern Applied Statistics with S\" (4th edition, 2002).\nTitle: Support Functions and Datasets for Venables and Ripley's MASS\nLazyData: yes\nByteCompile: yes\nLicense: GPL-2 | GPL-3\nURL: http://www.stats.ox.ac.uk/pub/MASS4/\nContact: &lt;MASS@stats.ox.ac.uk&gt;\nNeedsCompilation: yes\nPackaged: 2023-05-02 16:42:41 UTC; ripley\nAuthor: Brian Ripley [aut, cre, cph], Bill Venables [ctb], Douglas M.\n        Bates [ctb], Kurt Hornik [trl] (partial port ca 1998), Albrecht\n        Gebhardt [trl] (partial port ca 1998), David Firth [ctb]\nMaintainer: Brian Ripley &lt;ripley@stats.ox.ac.uk&gt;\nRepository: CRAN\nDate/Publication: 2023-05-04 07:32:21 UTC\nBuilt: R 4.3.2; x86_64-pc-linux-gnu; 2023-11-01 22:36:06 UTC; unix\n\n-- File: /opt/R/4.3.2/lib/R/library/MASS/Meta/package.rds \n\nlibrary(help='MASS')"
  },
  {
    "objectID": "01_introduction_to_r.html#installing-packages",
    "href": "01_introduction_to_r.html#installing-packages",
    "title": "Introduction to R",
    "section": "6.2 Installing packages",
    "text": "6.2 Installing packages\nThe R community contains some of the brightest and most generous mathematician, statisticians and practitioners who continue to actively develop and maintain concepts and routines. Most of these routines end up being packaged as a collection of functions and then hosted on one or more publicly available sites so that others can benefit from their efforts.\nThe locations of collections of packages are called repositories or ‘repos’ for short. There four main repositories are CRAN, Bioconductor, R-Forge and github. By default, R is only ‘tuned in’ to CRAN. That is any package queries or actions pertain just to the CRAN repositories.\nTo get a tabulated list of all the packages available on CRAN (warning there are over 5000 packages, so this will be a large table - I will suppress the output):\n\navailable.packages()\n\n\n6.2.1 Comprehensive R Archive Network - CRAN\nCRAN is a repository of R packages mirrored across 90 sites throughout the world. Packages are installed from CRAN using the install.packages() function. The first (and only mandatory) argument to the install.packages() function is the name of the package(s) to install (pkgs =). If no other arguments are provided, the install.packages() function will search CRAN for the specified package(s) and install it along with any of its dependencies that are not yet installed on your system.\nNote, unless you have started the session with administrator (root) privileges, the packages will be installed within a path of your home folder. Whilst this is not necessarily a bad thing, it does mean that the package is not globally available to all users on your system (not that it is common to have multiple users of a single system these days). Moreover, it means that R packages reside in multiple locations across your system. The packages that came with your R install will be in one location (or a couple or related locations) and the packages that you have installed will be in another location.\nTo see the locations currently used on your system, you can issue the following statement.\n\n.libPaths()\n\n[1] \"/home/runner/work/_temp/Library\" \"/opt/R/4.3.2/lib/R/site-library\"\n[3] \"/opt/R/4.3.2/lib/R/library\"     \n\n\nTo install a specific package (and its dependencies). The package that I have chosen to demonstrate this with (remotes) is a package that enables R packages to be installed from git repositories (such as github, and will be featured in a later subsection).\n\ninstall.packages(\"remotes\")\n\nYou will be prompted to select a mirror site. In the absence of any other criterion, just select the mirror that is closed geographically to you. The terminal will then provide feedback about the progress and status of the install process. By indicating a specific repository, you can avoid being prompted for a mirror. For example, I chose to use a CRAN mirror at Melbourne University (Australia), and therefore the following statement gives me direct access\n\ninstall.packages(\"remotes\", repos = \"http://cran.csiro.au\")\n\nFinally, you could provide a vector of repository names if you were unsure which repository was likely to contain the package you were after. This can also be useful if your preferred mirror regularly experiences downtime - the alternative mirror (second in the vector) is used only when the first fails.\n\n\n6.2.2 Bioconductor\nBioconductor is an open source and open development project devoted to genomic data analysis tools, most of which are available as R packages. Whilst initially the packages focused primarily on the manipulation and analysis of DNA microarrays, as the scope of the projects has expanded, so too has the functional scope of the packages there hosted.\n\nsource(\"http://bioconductor.org/biocLite.R\")\nbiocLite(\"limma\")\n\nOr to install multiple packages from Bioconductor\n\nsource(\"http://bioconductor.org/biocLite.R\")\nbiocLite(c(\"GenomicFeatures\", \"AnnotationDbi\"))\n\n\n\n6.2.3 R-Forge\nUnlike both CRAN and Bioconductor (which are essentially package repositories), R-Forge is an entire R package development platform. Package development is supported through a range of services including:\n\nversion control (SVN) - allowing multiple collaborators to maintain current and historical versions of files by facilitating simultaneous editing, conflict resolution and rolling back\ndaily package checking and building - so packages are always up to date\nbug tracking and feature request tools\nmailing lists and message boards\nfull backup and archival system\n\nAnd all of this within a mature content management system like web environment. Installing packages from R-Forge is the same as it is for CRAN, just that the path of the root repository needs to be specified with the repos= argument.\n\ninstall.packages(\"lme4.0\", repos = \"http://R-Forge.R-project.org\")\n\n\n\n6.2.4 Github (via remotes)\nGithub builds upon the philosophy of the development platform promoted by the Source Forge family (including R-Forge) by adding the ability to fork a project. Forking is when the direction of a project is split so that multiple new opportunities can be explored without jeopardizing the stability and integrity of the parent source. If the change in direction proves valuable, the project (package) can either become a new package or else feedback into the development of the original package.\nHadley Wickham and Co have yet again come up with a set of outrageously useful tools (remotes package). This package is a set of functions that simplify (albeit slightly dictatorially) the processes of installing packages from remote and local repositories (Github, Gitlab, Bitbucket etc)\nIn order to make use of this package to install packages from github, the remotes package must itself be installed (we did this earlier). It is recommended that this install take place from CRAN (as outline above). Thereafter, the remotes package can be included in the search path and the install_github function used to retrieve and install a nominated package or packages from Github.\n\nremotes::install_github(\"ggplot2\")\n\nAs described above, Github is a development platform and therefore it is also a source of ‘bleeding edge’ development versions of packages. Whilst the development versions are less likely to be as stable or even as statistically rigorous as the final release versions, they do offer the very latest ideas and routines. They provide the very latest snapshot of where the developers are currently at.\nMost of the time users only want the stable release versions of a package. However there are times when having the ability to try out new developments as they happen can be very rewarding. The install_dev() function allows for the installation of the development version of a package.\nThe more complex devtools package (also by Hadley Wickham et al) provides a set of functions that simplify (albeit slightly dictatorially) the processes of package authoring, building, releasing and installing. Within the devtools package, the dev_mode() function provides a switch that can be used to toggle your system in and out of development mode. When in development mode, installed packages are quarantined within a separate path (R-dev) to prevent them overriding or conflicting with the stable versions that are critical for your regular analyses.\n\n## switch to development mode\ndevtools::dev_mode(on = TRUE)\n##install the development version of ggplot2\ndevtools::install_github(\"ggplot2\")\n## use the development version of ggplot2 \nlibrary(ggplot2)\n## switch development mode off\ndevtools::dev_mode(on = FALSE)\n## stable version of ggplot2 is now engaged\n\n\n\n6.2.5 Manual download and install\nPackages are made available on the various repositories in compressed form and differ between Windows, MacOSX and Linux versions. Those web repositories all have functionality for navigating or searching through the repositories for specific packages. The packages (compressed files) can be directly downloaded from these sites.\nAdditionally, some packages are not available on the various repositories and firewalls and proxies can sometimes prevent R from accessing the repositories directly. In these cases, packages must be manually downloaded and installed.\nThere are a number of ways to install a package that resides locally. Note, do not uncompress the packages.\n\nFrom the command line (outside of R).\n\n\nR CMD INSTALL packagename \n\nwhere packagename is replaced by the path and name of the compressed package.\n\nUsing the install.packages() function by specifying repos = NULL.\n\n\ninstall.packages('packagename', repos=NULL)\n\nwhere packagename is replaced by the path (if not in the current working directory) and name of the compressed package.\n\nVia the Windows RGui, select the Install package(s) from local zip files… option of the Packages menu and select the compressed package."
  },
  {
    "objectID": "01_introduction_to_r.html#updating-packages",
    "href": "01_introduction_to_r.html#updating-packages",
    "title": "Introduction to R",
    "section": "6.3 Updating packages",
    "text": "6.3 Updating packages\nAn integral component of package management is being able to maintain an up to date system. Many packages are regularly updated so as to adopt new ideas and functionality. Indeed, it is the speed of functional evolution that sets R apart from most other statistical environments.\nAlong with the install.packages() function, there are three other functions to help manage and maintain the packages on your system.\n\nold.packages() compares the versions of packages you have installed with the versions of those packages available in the current repositories. It tabulates the names, install paths and versions of old packages on your system.\n\nold.packages()\n\nAlternative repositories (than CRAN) can be indicated via the repos   = argument.\n\nold.packages(repos = \"http://R-Forge.R-project.org\")\n## or even multiple repos\nold.packages(repos = c(\"http://cran.csiro.au\", \"http://R-Forge.R-project.org\"))\n\nnew.packages() provides a tabulated list of all the packages on the repository that are either not in your local install, or else are of a newer version. Note, with over 4000 packages available on CRAN, unless the repos= parameter is pointing to somewhere very specific (and with a narrow subset of packages) this function is rarely of much use.\n\nnew.packages()\n\nupdate.packages() downloads and installs packages for which newer versions of those packages identified as ‘old’ by the old.packages() function. Just like old.packages(), alternative or multiple repositories can be specified.\n\nupdate.packages()\n## or from alternative multiple repos\nupdate.packages(repos = c(\"http://cran.csiro.au\", \"http://R-Forge.R-project.org\"))"
  },
  {
    "objectID": "01_introduction_to_r.html#package-management-pak",
    "href": "01_introduction_to_r.html#package-management-pak",
    "title": "Introduction to R",
    "section": "6.4 Package management (pak)",
    "text": "6.4 Package management (pak)\nPackage management can be a relatively complex task. These days packages are sourced from a variety and mixture of locations (CRAN, Github etc). Furthermore, most packages have a complex network of dependencies (that is, they depend on other packages). The fine folk over at Rstudio have developed a package called pak that aims to provide a unified and simplified interface to package management.\nThis next-generation package installer offers several key advantages for the technical R user:\n\nParallel downloads: pak leverages multi-core processing to download multiple packages simultaneously, significantly reducing installation time.\nIntelligent dependency resolution: pak automatically resolves package dependencies, installing the necessary versions in the correct order, ensuring a seamless experience.\nExpanded package sources: pak supports installation from diverse repositories like Bioconductor and even GitHub URLs, providing access to a broader range of cutting-edge tools.\nFine-grained control: pak gives you the power to specify them explicitly, offering greater control over your R environment.\nExtensible architecture: pak exposes an API for building custom extensions and integrating seamlessly with your data science workflows.\n\nBefore we can take advantage of pak package management, it must first be installed from CRAN using the traditional package installation method.\n\ninstall.packages(\"pak\")\n\n\n6.4.1 Dependencies\nFor any given package, we can see the dependencies. To illustrate, I will focus on the Matrix package.\n\npak::pkg_deps(\"Matrix\")\n\nℹ Loading metadata database\n\n\n✔ Loading metadata database ... done\n\n\n\n\n\n# A data frame: 2 × 36\n  ref     type  direct directpkg status package version license needscompilation\n  &lt;chr&gt;   &lt;chr&gt; &lt;lgl&gt;  &lt;lgl&gt;     &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;lgl&gt;           \n1 lattice stan… FALSE  FALSE     OK     lattice 0.22-5  GPL (&gt;… TRUE            \n2 Matrix  stan… TRUE   TRUE      OK     Matrix  1.6-4   GPL (&gt;… TRUE            \n# ℹ 27 more variables: priority &lt;chr&gt;, md5sum &lt;chr&gt;, sha256 &lt;chr&gt;,\n#   filesize &lt;int&gt;, built &lt;chr&gt;, platform &lt;chr&gt;, rversion &lt;chr&gt;,\n#   repotype &lt;chr&gt;, repodir &lt;chr&gt;, target &lt;chr&gt;, deps &lt;list&gt;, mirror &lt;chr&gt;,\n#   sources &lt;list&gt;, remote &lt;list&gt;, error &lt;list&gt;, metadata &lt;list&gt;,\n#   dep_types &lt;list&gt;, params &lt;list&gt;, sysreqs &lt;chr&gt;, cache_status &lt;chr&gt;,\n#   sysreqs_packages &lt;list&gt;, sysreqs_pre_install &lt;chr&gt;,\n#   sysreqs_post_install &lt;chr&gt;, sysreqs_install &lt;chr&gt;, lib_status &lt;chr&gt;, …\n\n\nAfter some database checking, the above function returns a tibble (like a data frame, yet with some special properties that include truncated output) containing a row for each dependency. In this example, the tibble has just two rows (one for the Matrix package, and the other for its only dependency, the Lattice package). To save space, the many columns have been truncated, yet listed below the tibble.\nAlternatively, we could view the dependencies as a tree.\n\npak::pkg_deps_tree(\"Matrix\")\n\nMatrix 1.6-1.1 -&gt; 1.6-4 [upd][bld][cmp][dl] (2.88 MB)\n└─lattice 0.21-9 -&gt; 0.22-5 [upd][bld][cmp][dl] (599.04 kB)\n\nKey:  [upd] update | [dl] download | [bld] build | [cmp] compile\n\n\nWe can see from the above that the Matrix package depends on the Lattice package.\n\n\n6.4.2 Installing packages\nTo install a package:\n\nfrom CRAN or Bioconductor: just provide the package name as an argument\n\npak::pkg_install(\"tidyverse\")\n\nfrom Github: provide the package name in the form of user/repo. You can also nominate a specific branch (user/repo@branch) or tag (user/repo@tag).\n\npak::pkg_install(\"tidyverse/dplyr\")\n\n\nSimilarly, pak::pkg_install() can be used for package updating. If the package has not yet been installed, the package will be installed, yet if the package has already been installed, then it will instead be updated (unless it is already the most up to date version).\nIf the upgrade = TRUE argument is supplied, then all the dependencies will also be updated.\n\n\n6.4.3 Removing packages\nPackage can be removed using the pak::pkg_remove() function."
  },
  {
    "objectID": "01_introduction_to_r.html#namespaces",
    "href": "01_introduction_to_r.html#namespaces",
    "title": "Introduction to R",
    "section": "6.5 Namespaces",
    "text": "6.5 Namespaces\nEarly on in this tutorial, I presented a set of rules and recommendations for object naming. One recommendation that I stressed was to avoid using names for objects that are the names of common functions (like mean) so as to (hopefully) avoid conflicting with any of the functions built in to R.\nHaving made these recommendations, I will now say that R is not overly fragile and is sufficiently cleaver to enable it to resolve many naming conflicts. Object names are context specific (see also object overloading above).\nWhen the name of an object is supplied that could be used to refer to multiple objects (for example, if you had created an object called mean there would be two objects named mean - your object and the inbuilt function), R first attempts to determine which object you are likely to have been referring to.\nObjects are defined and apply within certain contexts or namespaces. Namespaces defined the context (environment) in which an object is available. Objects created within functions, remain local to those functions. Hence if an object is created within a function, it is not available outside that function.\nThe namespace provides a context in which R should look for an object (such as a function). Functions defined within packages are available for use, when the library is loaded. This is essentially adding the libraries namespace to the list of contexts to that R should search within when you confront it with an expression.\nAlternatively, we can prefix the function name with the package name (its namespace) thereby explicitly indicating the context in which the function is defined and thus, the function will be found.\nFor example, lets say we wanted to create sparse diagonal matrix (a matrix with values in the diagonals and blanks in the off diagonals. There is a function called Diagonal in the Matrix package. We could expose this function (and all others in the package via the library function or we could just prefix the function name with the package name.\n\n## call the Diagonal function (however it wont be found)\nDiagonal(3)\n\nError in Diagonal(3): could not find function \"Diagonal\"\n\n## call the diagonal function from the Matrix package\nMatrix::Diagonal(3)\n\n3 x 3 diagonal matrix of class \"ddiMatrix\"\n     [,1] [,2] [,3]\n[1,]    1    .    .\n[2,]    .    1    .\n[3,]    .    .    1\n\n\nSimilarly, prefixing the namespace to the function name allows us to explicitly nominate exactly which function we want to use in the event that there are two functions of the same name in different packages."
  },
  {
    "objectID": "02_editors.html",
    "href": "02_editors.html",
    "title": "Code Editors",
    "section": "",
    "text": "1 Introduction\nIn the previous tutorial, we installed R and began exploring the language. If this was your very first time using R and perhaps your first exposure to any programming language, it is likely that you worked through the tutorial using either the R Gui (if on windows) or the terminal application in MacOSX or Linux.\nWhilst these tools to provide direct interaction with the R engine, they do little to support your efforts to develop code, documentation and sophisticated analysis outputs. This is where code editors come in.\nCode editors are a specialized software tools designed for creating and modifying source code of computer programs. They provide essential features such as syntax highlighting, code completion, and error checking, enhancing the efficiency and accuracy of programming tasks. Code editors are essential for developers, offering a streamlined environment for writing, editing, and organizing code, facilitating the software development process.\nChoosing an appropriate code editor is crucial for efficient R development. Each editor offers unique features and interfaces, catering to different preferences and workflows. This guide will walk you through some of the popular choices, including RStudio, Visual Studio Code, Emacs, Neovim, and Sublime Text, helping you make an informed decision.\nOf these, particular emphasis will be placed on RStudio. This is primarily because it is specifically designed to be an Intergrated Development Environment (IDE) for R. It is developed by active members of the R community for the R community. Furthermore, because it is a dedicated R IDE, it works straight out of the box with little to no configuration necessary. By contrast, the other editors are general code editors and thus must be specifically configured to provide R based functionality.\n\n\n2 Editors\n\nRStudioVisual Studio CodeEmacsNeoVimSublime Text\n\n\n\n2.0.1 Overview\nRStudio stands out as a widely used and dedicated Integrated Development Environment (IDE) designed for R development. Its user-friendly interface and comprehensive features make it a popular choice among R users.\n\n\n2.0.2 Installation\n\nInstalling RStudio on Windows:Installing RStudio on macOS:Installing RStudio on Linux:\n\n\n\nDownload R:\n\nRStudio requires R to be installed. If you have not already done so, download and install R from the official CRAN website.\n\nDownload RStudio:\n\nVisit the RStudio Download page and select the “RStudio Desktop” version compatible with your Windows operating system.\n\nInstall RStudio:\n\nRun the downloaded RStudio installer and follow the installation wizard.\nAccept the default settings unless you have specific preferences.\n\nLaunch RStudio:\n\nAfter installation, launch RStudio from the Start menu or desktop shortcut.\n\n\n\n\n\nDownload R:\n\nIf you have not already done so, download and install R on macOS from the official CRAN website.\n\nDownload RStudio:\n\nNavigate to the RStudio Download page and choose the “RStudio Desktop” version for macOS.\n\nInstall RStudio:\n\nRun the downloaded RStudio package, and macOS will guide you through the installation process.\n\nLaunch RStudio:\n\nOpen RStudio from the Applications folder or use Spotlight to search for it.\n\n\n\n\n\nDownload R:\n\nIf you have not already done so, install R on your Linux distribution using the package manager. For example, on Ubuntu, run:\n\n\n\nsudo apt-get install r-base\n\n\nDownload RStudio:\n\nVisit the RStudio Download page and choose the appropriate RStudio Desktop version for your Linux distribution.\n\nInstall RStudio:\n\nRun the downloaded RStudio package, and follow any additional instructions based on your Linux distribution.\n\nLaunch RStudio:\n\nOpen a terminal and type rstudio to launch RStudio.\n\n\n\n\n\n\n\n2.0.3 Key Features\nRStudio offers an integrated scripting and console environment, extensive support for RMarkdown, and streamlined package management capabilities.\nI strongly encourage you to look over the RStudio user guide - particularly the Getting Started section.\n\n\n\n\n2.0.4 Overview\nVisual Studio Code (VSCode) is a versatile and extensible code editor known for its speed and efficiency. While not exclusively designed for R, it offers excellent support for the language through extensions.\n\n\n2.0.5 Installation\n\nDownload Visual Studio Code:\n\nVisit the Visual Studio Code Download page and choose the version suitable for your operating system (Windows, macOS, or Linux).\nFollow the installation instructions for your specific operating system.\n\nInstall Visual Studio Code:\n\nRun the downloaded installer and follow the installation wizard.\nAccept the default settings unless you have specific preferences.\n\nLaunch Visual Studio Code:\n\nAfter installation, launch VSCode from the Start menu or applications folder.\n\n\n\n\n2.0.6 Setting Up R Support in Visual Studio Code:\n\nInstall R Extension:\n\nOpen VSCode and go to the Extensions view by clicking on the square icon on the sidebar or using the shortcut Ctrl+Shift+X.\nSearch for “R” in the Extensions view search box.\nInstall the “R Language” extension provided by Yuki Ueda.\n\nConfigure R Path (Optional):\n\nOpen the VSCode settings by pressing Ctrl+, or navigating to File &gt; Preferences &gt; Settings.\nClick on the “Open Settings (JSON)” icon in the upper-right corner of the Settings tab.\nAdd the following JSON configuration to set the path to your R executable:\n\n\n\n\"r.rpath.windows\": \"C:\\\\Program Files\\\\R\\\\R-4.x.x\\\\bin\\\\x64\\\\R.exe\",  // Replace with your R path\n\n\nSelect R Interpreter:\n\nCreate or open an R script in VSCode.\nLook for the “Select an R interpreter” notification at the bottom-right corner.\nClick on “Select R Interpreter” and choose the R version you installed.\n\nInstall Required R Packages:\n\nOpen the integrated terminal in VSCode using Ctrl+` .\nInstall the necessary R packages (e.g., languageserver and formatR) by running the following commands:\n\n\n\ninstall.packages(\"languageserver\")\ninstall.packages(\"formatR\")\n\n\nReload Window:\n\nAfter configuring R support, it’s recommended to reload the VSCode window to apply the changes.\n\nVerify R Support:\n\nOpen R Script:\n\nCreate or open an R script (.R file) in VSCode.\n\nCheck R Features:\n\nVerify that R features such as syntax highlighting, code completion, and linting are functioning correctly.\n\nRun R Script:\n\nRun parts of your R script or the entire script to ensure that the R interpreter is correctly executing code.\n\n\n\n\n\n2.0.7 Key Features\nVSCode is lightweight, supports the R Language Server, and can be enhanced with various extensions to meet specific development needs.\n\n\n\n\n2.0.8 Overview\nEmacs is a highly customizable and extensible text editor renowned for its versatility. It may have a steeper learning curve, but its power lies in its ability to adapt to individual preferences.\n\n\n2.0.9 Installation\n\nDownload and Install Emacs:\n\nVisit the GNU Emacs Download page and select the appropriate version for your operating system (Windows, macOS, or Linux).\nFollow the installation instructions provided on the download page.\n\nLaunch Emacs:\n\nAfter installation, launch Emacs. On Windows, you can find it in the Start menu. On macOS and Linux, open a terminal and type emacs.\nConfiguring Emacs for R Support:\n\nInstall ESS (Emacs Speaks Statistics):\n\nESS is a package for Emacs that provides support for various statistical languages, including R.\nOpen Emacs and add the following to your Emacs configuration file (usually ~/.emacs or ~/.emacs.d/init.el):\n\n\n\n;; Add MELPA repository for package installation\n(require 'package)\n(add-to-list 'package-archives '(\"melpa\" . \"https://melpa.org/packages/\") t)\n(package-initialize)\n\n;; Install ESS package\n(unless (package-installed-p 'ess)\n  (package-refresh-contents)\n  (package-install 'ess))\n\n\nConfigure ESS:\n\nCustomize your Emacs configuration to set up ESS for R. Add the following lines to your configuration file:\n\n\n\n;; Configure ESS for R\n(require 'ess-site)\n\n\nSelect R Interpreter:\n\nOpen an R script in Emacs. ESS should automatically detect your R installation.\nIf needed, customize the R interpreter by adding the following line to your configuration file:\n\n\n\n(setq inferior-R-program-name \"/path/to/R\")\n\n\nUseful Keybindings (Optional):\n\nAdd keybindings for common ESS commands. For example:\n\n\n\n(global-set-key (kbd \"C-c C-k\") 'ess-eval-buffer)\n(global-set-key (kbd \"C-c C-r\") 'ess-eval-region)\n\n\nESS Documentation (Optional):\n\nAccess ESS documentation by typing C-h i to open the Info viewer, then select “ESS” from the menu.\n\nReload Configuration:\n\nAfter making changes to your Emacs configuration, restart Emacs or use M-x load-file to reload the configuration.\n\nVerify R Support:\n\nOpen R Script:\n\nCreate or open an R script (.R file) in Emacs.\n\nCheck ESS Features:\n\nVerify that ESS features such as syntax highlighting, code evaluation, and interaction with R are functioning correctly.\n\nRun R Script:\n\nEvaluate parts of your R script or the entire script to ensure that the R interpreter is correctly executing code.\n\n\n\n\n\n2.0.10 Key Features\nEmacs supports extensive extensibility through packages, boasts ESS (Emacs Speaks Statistics) for R integration, and offers Org Mode for literate programming.\n\n\n\n\n2.0.11 Overview\nNeovim is a modern and extensible text editor that builds on the foundation of Vim. It combines the efficiency of Vim with additional features for a more contemporary editing experience.\n\n\n2.0.12 Installation\n\nDownload and Install Neovim:\n\nVisit the Neovim GitHub Releases page and download the installer appropriate for your operating system (Windows, macOS, or Linux).\nFollow the installation instructions provided on the GitHub page.\n\nLaunch Neovim:\n\nAfter installation, launch Neovim. On Windows, you can find it in the Start menu or use the executable. On macOS and Linux, open a terminal and type nvim.\n\nConfiguring Neovim for R Support:\n\nInstall a Plugin Manager (Optional):\n\nWhile optional, using a plugin manager makes it easier to manage Neovim plugins. Popular choices include vim-plug and dein.vim.\nFollow the installation instructions provided by the chosen plugin manager.\n\n\nInstall Nvim-R Plugin:\n\nNvim-R is a plugin that enhances Neovim for R development.\nAdd the following lines to your Neovim configuration file (usually ~/.config/nvim/init.vim or ~/.vimrc):\n\n\n\n\" For vim-plug\nPlug 'jalvesaq/Nvim-R'\n\n\" For dein.vim\ncall dein#add('jalvesaq/Nvim-R')\n\n\nConfigure Nvim-R:\n\nCustomize your Neovim configuration to set up Nvim-R for R. Add the following lines to your configuration file:\n\n\n\n\" Set the path to your R executable (replace with your actual path)\nlet g:vimrplugin_Rexecutable = '/path/to/R'\n\n\" Enable filetype plugin and indentation\nfiletype plugin indent on\n\n\" Set R as the default file type for .R files\nau BufNewFile,BufRead *.R set filetype=r\n\n\nInstall Plugins:\n\nOpen Neovim and run the command to install the configured plugins:\n\nFor vim-plug: :PlugInstall\nFor dein.vim: :call dein#install()\n\n\nReload Configuration:\n\nAfter adding the configuration, restart Neovim or use :source % to reload the configuration.\n\nVerify R Support:\n\nOpen R Script:\n\nCreate or open an R script (.R file) in Neovim.\n\nCheck Nvim-R Features:\n\nVerify that Nvim-R features, such as syntax highlighting, code evaluation, and interaction with R, are functioning correctly.\n\nRun R Script:\n\nEvaluate parts of your R script or the entire script to ensure that the R interpreter is correctly executing code.\n\n\n\n\n\n2.0.13 Key Features\nNeovim maintains Vim compatibility, supports plugins for extended functionality, and emphasizes efficient text editing.\n\n\n\n\n2.0.14 Overview\nSublime Text is a lightweight yet feature-rich text editor appreciated for its speed and simplicity. While not R-specific, it offers a customizable environment suitable for various programming languages.\n\n\n2.0.15 Installation\n\nDownload and Install Sublime Text:\n\nVisit the Sublime Text Download page and download the installer for your operating system (Windows, macOS, or Linux).\nFollow the installation instructions provided on the website.\n\nLaunch Sublime Text:\n\nAfter installation, launch Sublime Text. You can find it in the Start menu on Windows, in the Applications folder on macOS, or by using the terminal on Linux.\n\nConfiguring Sublime Text for R Support:\n\nInstall Package Control:\n\nPackage Control is a package manager for Sublime Text. Follow the installation instructions on the Package Control website.\n\nInstall Terminus Package:\n\nOpen Sublime Text and press Ctrl+Shift+P (Windows/Linux) or Cmd+Shift+P (macOS) to open the command palette.\nType “Install Package” and select “Package Control: Install Package.”\nSearch for “Terminus” and install the package.\n\nInstall R:\n\nMake sure you have R installed on your system. You can download it from the official R website.\n\nConfigure Terminus for R:\n\nOpen Sublime Text and create or open an R script (.R file).\nPress Ctrl+ (Windows/Linux) or Cmd+ (macOS) to open the Terminus console.\nIn the Terminus console, type the following command to start an R session:\n\n\n\n\nR\n\n- Terminus will open a new terminal at the bottom of Sublime Text,\n  providing an interactive R session.\n- Create Build System (Optional):\n  - You can create a custom build system for R scripts to simplify\n    execution.\n    - Open a new file in Sublime Text and paste the following JSON\n      configuration:\n\n{\n    \"cmd\": [\"R\", \"--slave\", \"--vanilla\", \"-f\", \"$file\"],\n    \"file_regex\": \"^(?:(...*?):([0-9]+):([0-9]+)|(...*?))$\",\n    \"selector\": \"source.R\"\n}\n\n    - Save the file with the extension .sublime-build in the\n      \"User\" directory of your Sublime Text \"Packages\" folder. You\n      can find this folder by selecting \"Preferences\" &gt; \"Browse\n      Packages...\" in Sublime Text.\n  - Run R Script:\n    - Open an R script in Sublime Text.\n    - Use the Terminus console to interact with the R session and\n      execute commands.\n\n\n2.0.16 Key Features\nSublime Text boasts multiple cursors, supports extensions through Package Control, and provides ample customization options."
  },
  {
    "objectID": "03_data_frames.html",
    "href": "03_data_frames.html",
    "title": "Data frames",
    "section": "",
    "text": "Step 1\nBefore beginning this tutorial, we should make sure we have all the tools in place. We will therefore start by installing the tidyverse ecosystem of packages. Among the many packages included under this umbrella are the packages readr, readxl and tibble - each of which will be used in this tutorial.\nIn addition, the foreign package supports importing data from other statistical software (such as Sas, Stata, Systat, System and Minitab).\nLet start by installing the tidyverse ecosystem of packages along with foreign.\n\npak::pkg_install(\"tidyverse\")\npak::pkg_install(\"foreign\")\n\nNow we will load these packages so that they are available for the rest of the session.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(foreign)\n\n\n\n\n\n\n\nNote\n\n\n\nNotice in the above output, when we load the tidyverse package, some validation steps are performed to indicate which actual packages were loaded. Importantly, notice also that a couple of conflicts are identified. The first of these dplyr::filter() masks stats::filter() indicates that once the dplyr package was loaded the previous definition of a function called filter (from the stats package) was overwritten (masked) by a definition contained wihin the dplyr package.\nThis is not an error. Rather, it is a warning to advise that if you were expecting to call the filter function and were expecting to get the behaviour defined within the stats package, then you should preface the call with the stats namespace. For example, call stats::filter() rather than just filter().\nNo such issues arose when loading the foreign package.\n\n\nStep 2\nThe second necessary preparation is to prepare the file system for a tidy working environment. Rather than place all R scripts, data and outputs into a single (increasingly cluttered folder), it is always better to organise your project into a set number of folders. For this tutorial, I would recommend setting up the following structure.\n../\n|-- data\n|-- scripts\nNow within your chosen editor, I suggest you create an R script within the scripts folder and set this path as the working directory.\nStep 3\nThe final preparation step is to download some data files to use during this tutorial. These files should be placed in the data folder. Each of the files are abbreviated versions of the same Mac Nally (1996) data set, yet each is in a different format (some are text files, others are in formats of other software). Each format is listed below, along with a link to manually access the data and an R code snippet that will download the file and place it in the ../data folder.\n\nmacnally.csv: a comma separated format\n\ndownload.file('https://github.com/ReefCloud/workshops/tree/main/data/macnally.csv', '../data/macnally.csv')\n\nmacnally.txt: a tab separated format\n\ndownload.file('https://github.com/ReefCloud/workshops/tree/main/data/macnally.txt', '../data/macnally.txt')\n\nmacnally.xlsx: an excel workbook format\n\ndownload.file('https://github.com/ReefCloud/workshops/tree/main/data/macnally.xlsx', '../data/macnally.xlsx')"
  },
  {
    "objectID": "03_data_frames.html#data.frame",
    "href": "03_data_frames.html#data.frame",
    "title": "Data frames",
    "section": "2.1 data.frame",
    "text": "2.1 data.frame\nData frames are generated by amalgamating vectors of the same length together. To illustrate the translation of a data set (collection of variables) into an R data frame (collection of vectors), a portion of a real data set by Mac Nally (1996) in which the bird communities were investigated from 37 sites across five habitats in southeastern Australia will be used. Although the original data set includes the measured maximum density of 102 bird species from the 37 sites, for simplicity’s sake only two bird species (GST: gray shrike thrush, EYR: eastern yellow robin) and the first eight of the sites will be included. The truncated data set, comprises a single factorial (or categorical) variable, two continuous variables, and a set of site (row) names, and is as follows:\n\n\n\n\nSite\nHABITAT\nGST\nEYR\n\n\n\n\nReedy Lake\nMixed\n3.4\n0.0\n\n\nPearcedale\nGipps.Manna\n3.4\n9.2\n\n\nWarneet\nGipps.Manna\n8.4\n3.8\n\n\nCranbourne\nGipps.Manna\n3.0\n5.0\n\n\nLysterfield\nMixed\n5.6\n5.6\n\n\nRed Hill\nMixed\n8.1\n4.1\n\n\nDevilbend\nMixed\n8.3\n7.1\n\n\nOlinda\nMixed\n4.6\n5.3\n\n\n\nFirstly, we will generate the three variables (excluding the site labels as they are not variables) separately:\n\nhabitat &lt;- factor(c('Mixed', 'Gipps.Manna', 'Gipps.Manna', 'Gipps.Manna', 'Mixed',\n  'Mixed', 'Mixed', 'Mixed'))\ngst &lt;- c(3.4, 3.4, 8.4, 3.0, 5.6, 8.1, 8.3, 4.6)\neyr &lt;- c(0.0, 9.2, 3.8, 5.0, 5.6, 4.1, 7.1, 5.3)\n\nNext, use the list the names of the vectors as arguments in the data.frame() function to amalgamate the three separate variables into a single data frame (data set) which we will call macnally (after the author).\n\nmacnally &lt;- data.frame(habitat, gst, eyr)\nmacnally\n\n      habitat gst eyr\n1       Mixed 3.4 0.0\n2 Gipps.Manna 3.4 9.2\n3 Gipps.Manna 8.4 3.8\n4 Gipps.Manna 3.0 5.0\n5       Mixed 5.6 5.6\n6       Mixed 8.1 4.1\n7       Mixed 8.3 7.1\n8       Mixed 4.6 5.3\n\n\nNotice that each vector (variable) becomes a column in the data frame and that each row represents a single sampling unit (in this case, each row represents a different site). By default, the rows are named using numbers corresponding to the number of rows in the data frame. However, these can be altered to reflect the names of the sampling units by assigning a list of alternative names to the row.names() (data frame row names) property of the data frame.\n\nrow.names(macnally) &lt;- c('Reedy Lake', 'Pearcedale', 'Warneet', 'Cranbourne',\n  'Lysterfield', 'Red Hill', 'Devilbend', 'Olinda')\nmacnally\n\n                habitat gst eyr\nReedy Lake        Mixed 3.4 0.0\nPearcedale  Gipps.Manna 3.4 9.2\nWarneet     Gipps.Manna 8.4 3.8\nCranbourne  Gipps.Manna 3.0 5.0\nLysterfield       Mixed 5.6 5.6\nRed Hill          Mixed 8.1 4.1\nDevilbend         Mixed 8.3 7.1\nOlinda            Mixed 4.6 5.3"
  },
  {
    "objectID": "03_data_frames.html#expand.grid",
    "href": "03_data_frames.html#expand.grid",
    "title": "Data frames",
    "section": "2.2 expand.grid",
    "text": "2.2 expand.grid\nWhen the data set contains multiple fully crossed categorical variables (factors), the expand.grid() function provides a convenient way to create the factor vectors.\n\nexpand.grid(rep = 1:4, \n  B = paste(\"b\", 1:2, sep = \"\"), \n  A = paste(\"a\", 1:3, sep = \"\")\n)\n\n   rep  B  A\n1    1 b1 a1\n2    2 b1 a1\n3    3 b1 a1\n4    4 b1 a1\n5    1 b2 a1\n6    2 b2 a1\n7    3 b2 a1\n8    4 b2 a1\n9    1 b1 a2\n10   2 b1 a2\n11   3 b1 a2\n12   4 b1 a2\n13   1 b2 a2\n14   2 b2 a2\n15   3 b2 a2\n16   4 b2 a2\n17   1 b1 a3\n18   2 b1 a3\n19   3 b1 a3\n20   4 b1 a3\n21   1 b2 a3\n22   2 b2 a3\n23   3 b2 a3\n24   4 b2 a3"
  },
  {
    "objectID": "03_data_frames.html#as_tibble",
    "href": "03_data_frames.html#as_tibble",
    "title": "Data frames",
    "section": "2.3 as_tibble",
    "text": "2.3 as_tibble\nTibbles are a modern re-imagining of data frames in R that focus on clarity, consistency, and user-friendliness. While both data frames and tibbles both hold data in rows and columns, tibbles introduce several key differences:\n\nPreserved Data Types: Unlike data frames which coerce strings to factors, tibbles maintain the original data types, facilitating accurate analysis and avoiding surprises.\nExplicit Naming: Column names are always strings, preventing unintentional creation of numeric or logical variables.\nImproved Printing: Tibbles display a concise overview, presenting only the first 10 rows and all fitting columns to screen, making exploration more efficient.\nStreamlined Subsetting: Accessing specific columns is simpler and safer, minimizing potential errors related to partial matching.\n\nThe as_tibble function converts a data frame into a tibble.\n\nmacnally.tbl &lt;- as_tibble(macnally)\nmacnally.tbl\n\n# A tibble: 8 × 3\n  habitat       gst   eyr\n  &lt;fct&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 Mixed         3.4   0  \n2 Gipps.Manna   3.4   9.2\n3 Gipps.Manna   8.4   3.8\n4 Gipps.Manna   3     5  \n5 Mixed         5.6   5.6\n6 Mixed         8.1   4.1\n7 Mixed         8.3   7.1\n8 Mixed         4.6   5.3\n\n\nSince the example data set is so small, there is no appreciable difference in how it is presented as either a data frame or a tibble. It is mainly when the data sets get larger that the distinctions become more apparent."
  },
  {
    "objectID": "03_data_frames.html#tribble",
    "href": "03_data_frames.html#tribble",
    "title": "Data frames",
    "section": "2.4 tribble",
    "text": "2.4 tribble\nThe tribble() function allows us to construct tibbles directly.\n\nmacnally.tbl &lt;- tribble(\n  ~habitat, ~gst, ~eyr,\n  \"Mixed\", 3.4, 0.0,\n  \"Gipps.Manna\", 3.4, 9.2,\n  \"Gipps.Manna\", 8.4, 3.8,\n  \"Gipps.Manna\", 3.0, 5.0,\n  \"Mixed\", 5.6, 5.6,\n  \"Mixed\", 8.1, 4.1,\n  \"Mixed\", 8.3, 7.1,\n  \"Mixed\", 4.6, 5.3,\n  )\nmacnally.tbl\n\n# A tibble: 8 × 3\n  habitat       gst   eyr\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 Mixed         3.4   0  \n2 Gipps.Manna   3.4   9.2\n3 Gipps.Manna   8.4   3.8\n4 Gipps.Manna   3     5  \n5 Mixed         5.6   5.6\n6 Mixed         8.1   4.1\n7 Mixed         8.3   7.1\n8 Mixed         4.6   5.3\n\n\nNote that the construction of tibbles like this more closely resembles the eventual structure of the data. Compare this to the way data frames are constructed (by combining individual vectors)."
  },
  {
    "objectID": "03_data_frames.html#importing-from-text-file",
    "href": "03_data_frames.html#importing-from-text-file",
    "title": "Data frames",
    "section": "3.1 Importing from text file",
    "text": "3.1 Importing from text file\nThe easiest form of importation is from a pure text file. Since most software that accepts file input can read plain text files, text files can be created in all spreadsheet, database and statistical software packages and are also the default outputs of most data collection devices.\nIn a text file, data are separated (or delimited) by a specific character, which in turn defines what sort of text file it is. The text file should broadly represent the format of the data frame.\n\nvariables should be in columns and sampling units in rows. the first\nrow should contain the variable names and if there are row names, these should be in the first column\n\nThe following examples illustrate the format of the abbreviated Mac Nally (1996) data set created as both comma delimited (left) and tab delimited (right) files as well as the corresponding read.table() commands used to import the files.\n\n\n\n\n\n\nNote\n\n\n\nThe following examples assume that the above data will be in the current working directory. If the current working directory (which can be checked with the getwd() function) does not contain these files, then either:\n\ninclude the full path name (or path relative to the current working directory) as the filename argument\nchange the current working directory of your session prior to continuing (use the setwd() function)\ncopy and paste the files into the current working directory.\n\n\n\n\n\nComma delimited text file .csv\n\nLOCATION,HABITAT,GST,EYR\nReedy Lake,Mixed,3.4,0.0\nPearcedale,Gipps.Manna,3.4,9.2\nWarneet,Gipps.Manna,8.4,3.8\nCranbourne,Gipps.Manna,3.0,5.0\n....\n\n\nmacnally_new &lt;- read_csv(\"../data/macnally.csv\", \n  trim_ws = TRUE)\n\nRows: 37 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): LOCATION, HABITAT\ndbl (2): GST, EYR\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nmacnally_new\n\n# A tibble: 37 × 4\n   LOCATION      HABITAT              GST   EYR\n   &lt;chr&gt;         &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;\n 1 Reedy Lake    Mixed                3.4   0  \n 2 Pearcedale    Gipps.Manna          3.4   9.2\n 3 Warneet       Gipps.Manna          8.4   3.8\n 4 Cranbourne    Gipps.Manna          3     5  \n 5 Lysterfield   Mixed                5.6   5.6\n 6 Red Hill      Mixed                8.1   4.1\n 7 Devilbend     Mixed                8.3   7.1\n 8 Olinda        Mixed                4.6   5.3\n 9 Fern Tree Gum Montane Forest       3.2   5.2\n10 Sherwin       Foothills Woodland   4.6   1.2\n# ℹ 27 more rows\n\n\n\n\n\nTab delimited text file .txt\n\nLOCATION    HABITAT     GST EYR\nReedy Lake  Mixed       3.4 0.0\nPearcedale  Gipps.Manna 3.4 9.2\nWarneet     Gipps.Manna 8.4 3.8\nCranbourne  Gipps.Manna 3.0 5.0\n....\n\n\nmacnally_new &lt;- read_tsv(\"../data/macnally.txt\", \n  trim_ws = TRUE)\n\nRows: 37 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): LOCATION, HABITAT\ndbl (2): GST, EYR\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nmacnally_new \n\n# A tibble: 37 × 4\n   LOCATION      HABITAT              GST   EYR\n   &lt;chr&gt;         &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;\n 1 Reedy Lake    Mixed                3.4   0  \n 2 Pearcedale    Gipps.Manna          3.4   9.2\n 3 Warneet       Gipps.Manna          8.4   3.8\n 4 Cranbourne    Gipps.Manna          3     5  \n 5 Lysterfield   Mixed                5.6   5.6\n 6 Red Hill      Mixed                8.1   4.1\n 7 Devilbend     Mixed                8.3   7.1\n 8 Olinda        Mixed                4.6   5.3\n 9 Fern Tree Gum Montane Forest       3.2   5.2\n10 Sherwin       Foothills Woodland   4.6   1.2\n# ℹ 27 more rows\n\n\n\n\nIn the above, the trim_ws = TRUE argument indicates that leading and trailing spaces should be removed from all the data. This is important as often spreadsheets (I’m looking at you Excel), add spaces before or after words (in particular). These are invisible, yet can cause huge headaches when running analyses or graphing..\nThe read_csv and read_tzv functions provide feedback about what they have imported. Specifically, they list the number of rows and columns, what the delimeting character is and the data type assigned to each field (variable/column).\nThe data are imported as a tibble.\nThere are numerous ways to specify the filename.\n\nusing full paths\n\nmacnally_new &lt;- read_csv(\"/home/Project/data/macnally.csv\", trim_ws = TRUE)\n\n\n\n\n\n\n\nNote\n\n\n\nIn the above example, the full path used was appropriate for the machine that the code was run on. However, it is unlikely to reflect a valid path on your machine. You may want to adjust it accordingly.\n\n\nusing relative paths\n\nmacnally_new &lt;- read_csv(\"../data/macnally.csv\", trim_ws = TRUE)\n\n\n\n\n\n\n\nNote\n\n\n\nRecall that ../data/ means navigate out of the current directory and into the data directory.\n\n\nusing ULRs\n\nmacnally_new &lt;- read_csv(url(\"https://github.com/ReefCloud/workshops/tree/main/data/macnally.csv\"), trim_ws = TRUE)\n\nIn the above example, the data are accessed directly from a remote location."
  },
  {
    "objectID": "03_data_frames.html#importing-from-the-clipboard",
    "href": "03_data_frames.html#importing-from-the-clipboard",
    "title": "Data frames",
    "section": "3.2 Importing from the clipboard",
    "text": "3.2 Importing from the clipboard\nThe read_tsv() function can also be used to import data (into a tibble) that has been placed on the clipboard by other software, thereby providing a very quick and convenient way of obtaining data from spreadsheets. Simply replace the filename argument with the clipboard() function. For example, to import data placed on the clipboard from Microsoft Excel, select the relevant cells, click copy and then in R, use the following syntax;\n\nmacnally_new &lt;- read_tsv(clipboard(), trim_ws = TRUE)\n\n\n\n\n\n\n\nWarning\n\n\n\nAlthough importing data from the clipboard can be convenient for quickly exploring something, it should mostly be discouraged from a reproducibility perspective:\n\nwhen such code is included in a script, the script will just import whatever is present on the clipboard at the time - which may or may not be what you expect it to be\nthere is no way to record the providence of the data because it is not pointing to a specific file or source."
  },
  {
    "objectID": "03_data_frames.html#importing-from-excel",
    "href": "03_data_frames.html#importing-from-excel",
    "title": "Data frames",
    "section": "3.3 Importing from Excel",
    "text": "3.3 Importing from Excel\nMicrosoft Excel is more than just a spreadsheet, it can contain macros, formulae, multiple worksheets and formatting. There are numerous ways to import xlsx files into R, yet depending on the complexity of the original files, the translations can be incomplete and inconsistent.\nOne of the easiest and safest ways to import data from Excel is either to save the worksheet as a text file (comma or tab delimited) and import the data as a text file (see above), or to copy the data to the clipboard in Excel and import the clipboard data into R.\nNevertheless, it is also possible to directly import a sheet from an excel workbook. Tidyverse includes a package called readxl, however as it is not one of the ‘core’ packages, it is not automatically loaded as part of the ecosystem when the tidyverse package is loaded. Hence to use the readxl package, it must be explicitly loaded.\n\nlibrary(readxl)\nmacnally_new &lt;- read_xlsx(\"../data/macnally.xlsx\", sheet = \"macnally\", trim_ws = TRUE)"
  },
  {
    "objectID": "03_data_frames.html#summary",
    "href": "03_data_frames.html#summary",
    "title": "Data frames",
    "section": "4.1 summary()",
    "text": "4.1 summary()\nThe summary() function is an overloaded function whose behaviour depends on the object passed to the function. When summary() is called with a data.frame, a summary is provided in which:\n\nnumeric vectors (variables) are summarized by the standard 5 number statistics and if there are any missing values, the number of missing values is also provided\ncategorical (factors) vectors are tallied up - that is, the number of instances of each level are counted.\nboolean states are also tallied\ncharacter vectors are only described by their length\ndate (and POSIX) vectors are summarized by 5 number summaries\n\n\nsummary(macnally)\n\n        habitat       gst            eyr           bool        \n Gipps.Manna:3   Min.   :3.00   Min.   :0.000   Mode :logical  \n Mixed      :5   1st Qu.:3.40   1st Qu.:4.025   FALSE:4        \n                 Median :5.10   Median :5.150   TRUE :4        \n                 Mean   :5.60   Mean   :5.013                  \n                 3rd Qu.:8.15   3rd Qu.:5.975                  \n                 Max.   :8.40   Max.   :9.200                  \n     char                date           \n Length:8           Min.   :2000-02-29  \n Class :character   1st Qu.:2000-03-18  \n Mode  :character   Median :2000-04-05  \n                    Mean   :2000-04-05  \n                    3rd Qu.:2000-04-23  \n                    Max.   :2000-05-12"
  },
  {
    "objectID": "03_data_frames.html#str",
    "href": "03_data_frames.html#str",
    "title": "Data frames",
    "section": "4.2 str()",
    "text": "4.2 str()\nSimilar to summary(), the str() function is an overloaded. The str() function generally produces a compact view of the structure of an object. When str() is called with a data.frame, this compact view comprises a nested list of abbreviated structures.\n\nstr(macnally)\n\n'data.frame':   8 obs. of  6 variables:\n $ habitat: Factor w/ 2 levels \"Gipps.Manna\",..: 2 1 1 1 2 2 2 2\n $ gst    : num  3.4 3.4 8.4 3 5.6 8.1 8.3 4.6\n $ eyr    : num  0 9.2 3.8 5 5.6 4.1 7.1 5.3\n $ bool   : logi  TRUE FALSE TRUE FALSE TRUE FALSE ...\n $ char   : chr  \"Large\" \"Small\" \"Large\" \"Small\" ...\n $ date   : Date, format: \"2000-02-29\" \"2000-03-10\" ..."
  },
  {
    "objectID": "03_data_frames.html#glimpse",
    "href": "03_data_frames.html#glimpse",
    "title": "Data frames",
    "section": "4.3 glimpse()",
    "text": "4.3 glimpse()\nThe glimpse() function in the tibble package is similar to str() except that it attempts to maximize the amount of data displayed according to the dimensions of the output.\n\nglimpse(macnally)\n\nRows: 8\nColumns: 6\n$ habitat &lt;fct&gt; Mixed, Gipps.Manna, Gipps.Manna, Gipps.Manna, Mixed, Mixed, Mi…\n$ gst     &lt;dbl&gt; 3.4, 3.4, 8.4, 3.0, 5.6, 8.1, 8.3, 4.6\n$ eyr     &lt;dbl&gt; 0.0, 9.2, 3.8, 5.0, 5.6, 4.1, 7.1, 5.3\n$ bool    &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE\n$ char    &lt;chr&gt; \"Large\", \"Small\", \"Large\", \"Small\", \"Large\", \"Small\", \"Large\",…\n$ date    &lt;date&gt; 2000-02-29, 2000-03-10, 2000-03-20, 2000-03-31, 2000-04-10, 20…"
  },
  {
    "objectID": "03_data_frames.html#others",
    "href": "03_data_frames.html#others",
    "title": "Data frames",
    "section": "4.4 Others",
    "text": "4.4 Others\nThere are also numerous graphical methods including view() and fix(), however, I have focused on the script friendly routines. As the graphical routines require user input, they are inappropriate to include in scripts.\nWithin Rstudio, a data frame can be viewed like a spreadsheet. To view the data this way, click on the name of the data frame within the Environment pane. Furthermore, when in R Notebook mode, a simple functioning spreadsheet will be embedded within the notebook."
  },
  {
    "objectID": "03_data_frames.html#saverdsreadrds",
    "href": "03_data_frames.html#saverdsreadrds",
    "title": "Data frames",
    "section": "6.1 saveRDS/readRDS",
    "text": "6.1 saveRDS/readRDS\nFor example:\n\n## save just the macnally data frame to the data folder\nsaveRDS(macnally, file = \"../data/macnally.rds\")\n\nThis will save a single object in a compressed format.\nThe saved object(s) can be loaded during subsequent sessions by providing the name of the saved workspace image file as an argument to the load() function. For example:\n\nmacnally &lt;- readRDS(\"../data/macnally_stats.rds\")"
  },
  {
    "objectID": "03_data_frames.html#saveload",
    "href": "03_data_frames.html#saveload",
    "title": "Data frames",
    "section": "6.2 save/load",
    "text": "6.2 save/load\nWhen you want to save multiple objects, the save() function is convenient. This stores multiple objects in a binary (non-compressed) format.\n\n## save just the macnally data frame to the data folder\nsave(macnally, file = \"../data/macnally.RData\")\n## calculate the mean gst\nmean_gst &lt;- mean(macnally$gst)\n## display the mean gst\nmean_gst\n## save the macnally data frame as well as the mean gst object\nsave(macnally, mean_gst, file = \"../data/macnally_stats.RData\")\n\nThe saved object(s) can be loaded during subsequent sessions by providing the name of the saved workspace image file as an argument to the load() function. For example:\n\nload(\"../data/macnally_stats.RData\")\n\nNote, the load() reads the object(s) into the current environment with each object being assigned the names they were originally assigned when they were saved."
  },
  {
    "objectID": "03_data_frames.html#dump",
    "href": "03_data_frames.html#dump",
    "title": "Data frames",
    "section": "6.3 dump",
    "text": "6.3 dump\nSimilarly, a straight un-encoded text version of an object (including dataframes and tibbles) can be saved or added to a text file (such as an R script) using the dump() function.\n\ndump(\"macnally\", file = \"../data/macnally\")\n\nIf the file character string is left empty, the text representation of the object will be written to the console. This output can then be viewed or copied and pasted into a script file, thereby providing a convenient way to bundle together data sets along with graphical and analysis commands that act on the data sets. It can even be used to paste data into an email.\n\ndump(\"macnally\", file = \"\")\n\nThereafter, the dataset is automatically included when the script is sourced and cannot accidentally become separated from the script."
  }
]